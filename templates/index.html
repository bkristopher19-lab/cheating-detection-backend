<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover,user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0f1724">
    <title>Online Exam with Proctoring</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>

        /* ---------- PROCTORING COLLAPSE ---------- */
.detection-area {
  flex: 0 0 auto;
  transition: height 0.3s ease;
  background: var(--card);
  border-bottom: 1px solid rgba(255,255,255,.1);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  position: relative;
  height: auto;
  /* Optimize for mobile performance */
  will-change: height;
  contain: layout style paint;
}

.proctor-toggle {
  position: absolute;
  top: 8px;
  right: 8px;
  background: var(--accent);
  color: #032;
  border: none;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  font-size: 1.2rem;
  line-height: 1;
  cursor: pointer;
  z-index: 10;
  box-shadow: 0 2px 6px rgba(0,0,0,.3);
  transition: all 0.3s ease;
}

.detection-area.collapsed {
  height: 44px !important;
  border-bottom: none;
}

.detection-area.collapsed #alerts,
.detection-area.collapsed .mic-ui,
.detection-area.collapsed .controls,
.detection-area.collapsed #processed,
.detection-area.collapsed #captions,
.detection-area.collapsed #studentAlertDistribution,
.detection-area.collapsed .proctor-header {
  display: none !important;
}

/* Keep video element hidden but functional when collapsed */
.detection-area.collapsed .media {
  position: absolute;
  opacity: 0;
  pointer-events: none;
  z-index: -1;
}

        .proctor-header {
  padding: 0.6rem 1rem;
  display: flex;
  align-items: center;
  gap: 8px;
  background: rgba(255,255,255,.04);
  border-bottom: 1px solid rgba(255,255,255,.1);
  font-size: 0.9rem;
}

.back-btn {
  background: none;
  border: none;
  color: #e6eef8;
  font-size: 1.2rem;
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.back-btn:hover {
  background: rgba(255,255,255,0.1);
}
        /* Keep existing styles */
        :root{
            --bg:#0f1724;
            --card: rgba(255,255,255,0.06);
            --accent: #6ee7b7;
            --muted: #9aa4b2;
            --radius: 14px;
        }
        
        /* Horizontal layout: proctoring on left, exam on right */
        .exam-container {
            display: flex;
            min-height: 100vh;
            background: var(--bg);
            color: #e6eef8;
            /* Optimize for mobile performance */
            contain: layout style;
        }

        .detection-area {
            flex: 0 0 380px;
            background: var(--card);
            border-right: 1px solid rgba(255,255,255,.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .exam-questions {
            flex: 1;
            padding: 2rem;
            background: var(--card);
            border-left: 1px solid rgba(255,255,255,.1);
            display: flex;
            flex-direction: column;
        }

        .question-card {
            background: var(--card);
            border-radius: var(--radius);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .answer-option {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 0.8rem 1rem;
            margin: 0.5rem 0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .answer-option:hover {
            background: rgba(255,255,255,0.08);
        }

        .answer-option.selected {
            background: rgba(110,231,183,0.1);
            border-color: var(--accent);
        }

        .timer {
            text-align: center;
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 1rem;
            padding: 1rem;
            background: rgba(255,255,255,.05);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,.1);
        }

        /* Keep rest of existing styles */
        html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial; background: linear-gradient(180deg,#071023 0%, #0b2440 100%); color:#e6eef8}
        body{background-color:#0b2440}
        *,*::before,*::after{box-sizing:border-box}
        .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:28px;
            padding-bottom: calc(28px + constant(safe-area-inset-bottom));
            padding-bottom: calc(28px + env(safe-area-inset-bottom));
        }
        .app{width:100%;max-width:760px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:18px;padding:18px;box-shadow:0 10px 30px rgba(2,6,23,0.7);display:grid;grid-template-columns:1fr;gap:18px;align-items:start}
        header.app-header{display:flex;align-items:center;gap:12px}
        .logo{width:48px;height:48px;border-radius:12px;background:linear-gradient(135deg,var(--accent),#4dd0e1);display:flex;align-items:center;justify-content:center;color:#032; font-weight:700}
        .title{font-size:1.05rem;font-weight:600}
        .subtitle{font-size:0.85rem;color:var(--muted);margin-top:4px}

        /* video area */
        .viewer{background:var(--card);border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:10px;align-items:center}
        .media{position:relative;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.04);width:100%}
        video{display:block;width:100%;height:auto;background:#000; /* Optimize for performance */ will-change: transform;}
        /* hide raw camera feed visually ‚Äî MediaPipe still uses the hidden video element */
        .media video{display:none !important}
        #processed{display:block;width:100%;height:auto;object-fit:cover;border-radius:8px; /* Optimize for performance */ will-change: auto;}
        .controls{display:flex;align-items:center;justify-content:space-between;gap:12px;width:100%}
        #label{font-weight:600;font-size:1rem}
        .prob{display:flex;gap:8px;align-items:center}
        .bar{height:10px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;width:140px}
        .bar > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#4dd0e1);width:0%}

        /* minimal: hide sidebar and controls we don't need */
        .sidebar{display:none}
        #toggle{display:none}

        .small{font-size:0.86rem;color:var(--muted)}

        /* Alerts */
        #alerts{width:100%;max-width:760px;display:flex;flex-direction:column;gap:8px;margin-top:6px}
        .alert{display:none;padding:10px 12px;border-radius:10px;font-weight:600;align-items:center;gap:8px}
        .alert.show{display:flex}
        .alert.warn{background:rgba(255,165,0,0.08);color:#ffd59a;border:1px solid rgba(255,165,0,0.12)}
        .alert.danger{background:rgba(255,80,80,0.06);color:#ffb3b3;border:1px solid rgba(255,80,80,0.12)}
        .alert.info{background:rgba(110,231,183,0.04);color:var(--accent);border:1px solid rgba(110,231,183,0.08)}

        /* Mic UI */
        .mic-ui{width:100%;max-width:760px;margin-top:6px;padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px}
        .mic-row{display:flex;align-items:center;gap:12px}
        .mic-label{font-weight:600}
        .mic-meter{flex:1;height:10px;background:rgba(255,255,255,0.04);border-radius:8px;overflow:hidden}
        .mic-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#4dd0e1)}
        .mic-status{font-size:0.86rem;color:var(--muted);min-width:120px;text-align:right}

        /* Student Alert Distribution Panel */
        .student-alert-distribution {
            transition: all 0.3s ease;
        }
        .student-alert-distribution .badge {
            transition: transform 0.2s ease;
        }






        /* Permission Modal Styles */
        .permission-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        .permission-content {
            background: var(--card);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }
        .permission-header h3 {
            margin: 0 0 0.5rem 0;
            color: #e6eef8;
            font-size: 1.5rem;
        }
        .permission-header p {
            margin: 0 0 1.5rem 0;
            color: var(--muted);
            line-height: 1.4;
        }
        .permission-details {
            margin-bottom: 2rem;
        }
        .permission-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background: rgba(255,255,255,0.02);
            border-radius: 8px;
        }
        .permission-icon {
            font-size: 2rem;
            width: 3rem;
            text-align: center;
        }
        .permission-item strong {
            color: #e6eef8;
            display: block;
            margin-bottom: 0.25rem;
        }
        .permission-item p {
            margin: 0;
            color: var(--muted);
            font-size: 0.9rem;
        }
        .permission-buttons {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }
        .permission-buttons .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .permission-buttons .btn-primary {
            background: var(--accent);
            color: #032;
        }
        .permission-buttons .btn-primary:hover {
            background: #4dd0e1;
        }
        .permission-buttons .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e6eef8;
        }
        .permission-buttons .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Mobile adjustments for exam layout */
        @media (max-width: 768px) {
            .exam-container {
                flex-direction: column;
                height: 100vh;
                height: -webkit-fill-available; /* iOS Safari fix */
                overflow: hidden;
            }
            .detection-area {
                flex: 0 0 auto;
                height: auto;
                max-height: 35vh; /* Reduced height for better exam visibility */
                border-right: none;
                border-bottom: 1px solid rgba(255,255,255,.1);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch; /* Smooth iOS scrolling */
            }
            .detection-area.collapsed {
                height: 44px;
                min-height: 44px;
            }
            .detection-area:not(.collapsed) {
                max-height: 35vh;
            }
            .exam-questions {
                flex: 1;
                padding: 1rem;
                border-left: none;
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch; /* Smooth iOS scrolling */
                height: calc(100vh - 35vh - 44px); /* Dynamic height */
                height: calc(-webkit-fill-available - 35vh); /* iOS fix */
                min-height: 0; /* Allow flex shrinking */
            }
            .timer {
                font-size: 1.2rem;
                padding: 0.8rem;
                margin-bottom: 0.5rem;
                position: sticky;
                top: 0;
                background: var(--card);
                z-index: 10;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            }
            .proctor-toggle {
                display: block !important; /* Always show toggle on mobile */
            }
            /* Reduce video size on mobile */
            .media video, #processed {
                max-height: 180px;
                width: 100%;
                object-fit: cover;
            }
            /* Optimize controls for mobile */
            .controls, .mic-ui {
                font-size: 0.85rem;
                padding: 6px;
            }
            /* Touch-friendly answer buttons */
            .answer-option {
                min-height: 48px; /* Minimum touch target for mobile */
                padding: 1rem;
                font-size: 1rem;
                -webkit-tap-highlight-color: rgba(110,231,183,0.3);
                touch-action: manipulation; /* Prevent double-tap zoom */
            }
            .question-card {
                padding: 1rem;
                margin-bottom: 1rem;
            }
            /* Prevent text selection on mobile */
            .exam-questions {
                -webkit-user-select: none;
                user-select: none;
            }
            /* Fix submit button on mobile */
            .submit-btn, .btn {
                min-height: 48px;
                font-size: 1rem;
                padding: 1rem 2rem;
                -webkit-tap-highlight-color: rgba(110,231,183,0.3);
                touch-action: manipulation; /* Prevent double-tap zoom */
            }
            /* Prevent zoom on input focus (iOS) */
            input, textarea, select {
                font-size: 16px !important;
            }
            /* Better touch handling */
            button, .answer-option, .btn {
                touch-action: manipulation;
                -webkit-user-select: none;
                user-select: none;
                cursor: pointer;
            }
            /* Active state for touch feedback */
            .answer-option:active {
                background: rgba(110,231,183,0.2) !important;
                transform: scale(0.98);
            }
            /* Ensure exam questions container is properly scrollable */
            .exam-questions {
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
            }
        }
        
        /* Small mobile devices */
        @media (max-width: 480px) {
            .exam-questions {
                padding: 0.75rem;
            }
            .question-card {
                padding: 0.75rem;
                margin-bottom: 0.75rem;
            }
            .answer-option {
                padding: 0.875rem;
                min-height: 44px;
            }
            .timer {
                font-size: 1rem;
                padding: 0.6rem;
            }
            .detection-area {
                max-height: 28vh;
            }
            .exam-questions {
                height: calc(100vh - 28vh - 44px);
                height: calc(-webkit-fill-available - 28vh);
            }
        }
        
        /* Fix iOS Safari viewport height issues */
        @supports (-webkit-touch-callout: none) {
            .exam-container {
                min-height: -webkit-fill-available;
                height: -webkit-fill-available;
            }
            html, body {
                height: -webkit-fill-available;
            }
        }
        
        /* Android Chrome viewport fixes */
        @media screen and (-webkit-min-device-pixel-ratio: 1) {
            .exam-container {
                min-height: 100vh;
                min-height: 100dvh; /* Dynamic viewport height */
            }
        }

        @media (max-width:520px){
            .caption-line{font-size:0.92rem}
            .permission-content {
                padding: 1.5rem;
                margin: 1rem;
            }
            .permission-item {
                flex-direction: column;
                text-align: center;
                gap: 0.5rem;
            }
            .permission-buttons {
                flex-direction: column;
            }
            .permission-buttons .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Permission Request Modal -->
    <div id="permissionModal" class="permission-modal">
        <div class="permission-content">
            <div class="permission-header">
                <h3>Camera & Microphone Access Required</h3>
                <p>To take this exam, we need access to your camera and microphone for proctoring purposes.</p>
            </div>
            <div class="permission-details">
                <div class="permission-item">
                    <div class="permission-icon">üìπ</div>
                    <div>
                        <strong>Camera Access</strong>
                        <p>Used to monitor your exam environment and ensure you remain visible.</p>
                    </div>
                </div>
                <div class="permission-item">
                    <div class="permission-icon">üé§</div>
                    <div>
                        <strong>Microphone Access</strong>
                        <p>Used to detect unusual sounds and ensure a quiet testing environment.</p>
                    </div>
                </div>
            </div>
            <div class="permission-buttons">
                <button class="btn btn-secondary" onclick="denyPermissions()">Deny Access</button>
                <button class="btn btn-primary" onclick="requestPermissions()">Allow Access</button>
            </div>
        </div>
    </div>

    <div class="exam-container" id="examContainer" style="display: none;">
        <!-- Left side: Proctoring -->
    <div class="detection-area" id="detectionArea">


        <div class="proctor-header">
            <button class="back-btn" onclick="window.history.back()" title="Go Back">
                <i class="bx bx-arrow-back"></i>
            </button>
            <div class="logo">
                    <img src="static/images/logo.jpg.jpg" alt="Logo" style="width:32px;height:32px;border-radius:8px;object-fit:cover">
            </div>
            <div class="title">Proctoring Active</div>
        </div>

        <div class="viewer">
            <!-- Alerts area -->
            <div id="alerts" aria-live="polite">
                <div id="alert-noface" class="alert danger">No face detected!</div>
                <div id="alert-multiplefaces" class="alert warn">Multiple faces detected!</div>
                <div id="alert-phone" class="alert warn">Phone detected!</div>
                <div id="alert-loudsound" class="alert danger">Loud sound detected!</div>

                <div id="alert-mvoices" class="alert danger">Multiple voices detected!</div>
            </div>

            <div class="media">
                <video id="video" autoplay playsinline></video>
            </div>

            <div class="controls">
                <div id="label">Waiting for frames...</div>
                <div class="prob">
                    <div class="bar"><i id="barFill"></i></div>
                    <div id="probText" class="small">‚Äî</div>
                </div>
            </div>

            <img id="processed" src="" alt="Processed preview" />

            <div class="mic-ui" aria-live="polite">
                <div class="mic-row">
                    <div class="mic-label">Microphone</div>
                    <div class="mic-meter"><div id="micFill" class="mic-fill"></div></div>
                    <div id="micStatus" class="mic-status">Initializing‚Ä¶</div>
                </div>
            </div>

            <!-- Captions area -->
                <div id="captions" class="captions" aria-live="polite" style="display:block; margin-top:10px; padding:8px; background:rgba(0,0,0,0.5); border-radius:8px; font-size:0.9rem; color:#e6eef8; min-height:30px;">Listening...</div>

                <!-- Alert Distribution Panel for Students -->
                <div id="studentAlertDistribution" class="student-alert-distribution" style="margin-top:15px; padding:12px; background:rgba(255,255,255,0.05); border-radius:10px; border:1px solid rgba(255,255,255,0.1);">
                    <div style="font-weight:600; font-size:0.95rem; margin-bottom:10px; color:#e6eef8; display:flex; align-items:center; gap:8px;">
                        <span>‚ö†Ô∏è</span>
                        <span>Your Violations</span>
            </div>
                    <div class="alert-dist-list" style="display:flex; flex-direction:column; gap:6px; font-size:0.85rem;">
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffd59a;">Multiple Faces</span>
                            <span class="badge" id="student-alert-twofaces" style="background:rgba(255,165,0,0.2); color:#ffd59a; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
        </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffb3b3;">Loud Sound</span>
                            <span class="badge" id="student-alert-loud-sound" style="background:rgba(255,80,80,0.2); color:#ffb3b3; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffd59a;">Phone Detected</span>
                            <span class="badge" id="student-alert-phone" style="background:rgba(255,165,0,0.2); color:#ffd59a; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                    </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffb3b3;">Fullscreen Exit</span>
                            <span class="badge" id="student-alert-fullscreen-exit" style="background:rgba(255,80,80,0.2); color:#ffb3b3; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                    </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffd59a;">Keyboard Shortcut</span>
                            <span class="badge" id="student-alert-keyboard-shortcut" style="background:rgba(255,165,0,0.2); color:#ffd59a; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                    </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffd59a;">Right Click</span>
                            <span class="badge" id="student-alert-right-click" style="background:rgba(255,165,0,0.2); color:#ffd59a; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                    </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffd59a;">Tab Switch</span>
                            <span class="badge" id="student-alert-tab-switch" style="background:rgba(255,165,0,0.2); color:#ffd59a; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                    </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffd59a;">Speech Detected</span>
                            <span class="badge" id="student-alert-captions" style="background:rgba(255,165,0,0.2); color:#ffd59a; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                    </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffb3b3;">Face Absent</span>
                            <span class="badge" id="student-alert-face-absent" style="background:rgba(255,80,80,0.2); color:#ffb3b3; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                    </div>
                    </div>
                    </div>
                </div>
</div>

        <!-- Right side: Exam Questions -->
        <div class="exam-questions">
            <div class="timer" id="examTimer">Time Left: 60:00</div>

            <h2 id="examTitle">Quiz 1</h2>
            <p class="text-white mb-4" id="examSubject">Subject: CC105</p>

            <div id="questionsContainer">
                <!-- Questions will be loaded here -->
                </div>

            <button class="btn btn-primary mt-4" onclick="submitExam()">Submit Exam</button>
    </div>
</div>

    <canvas id="canvas" width="640" height="360" style="display:none;"></canvas>

    <script>

</script>
    <!-- Keep existing scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <!-- Add new script for exam functionality -->
    <script>
        // Function to show exam alerts to students
        function showExamAlert(message) {
            // Create or get alert element
            let alertBox = document.getElementById('examInlineAlert');
            if (!alertBox) {
                alertBox = document.createElement('div');
                alertBox.id = 'examInlineAlert';
                alertBox.style.cssText = 'position:fixed; top:20px; left:50%; transform:translateX(-50%); background:rgba(255,193,7,0.95); color:#000; padding:12px 20px; border-radius:8px; font-weight:600; z-index:10000; box-shadow:0 4px 12px rgba(0,0,0,0.3); max-width:500px; text-align:center;';
                document.body.appendChild(alertBox);
            }

        alertBox.textContent = message;
            alertBox.style.display = 'block';

            // Auto-hide after 3 seconds
        setTimeout(() => {
                if (alertBox) {
                    alertBox.style.display = 'none';
                }
        }, 3000);
    }

        // Exam state
        let examState = {
            examId: null,
            userId: null,
            answers: [],
            submitted: false,
            terminated: false, // Flag to indicate if exam was terminated due to violation
            questions: [], // Store exam questions for speech detection
            allAnswers: [] // Store all possible answers for speech detection
        };

        // Update alertsSession structure to include captions and clip recording
        let alertsSession = {
            sessionId: null,
            userId: null,
            examId: null,
            flags: {
                face_absent: [],
                twofaces: [],
                loud_sound: [],
                phone: [],
                fullscreen_exit: [],
                keyboard_shortcut: [],
                right_click: [],
                tab_switch: [],
                captions: []
            },
            clipRecorded: false, // Track if a cheating clip has been recorded
            clipRecorder: null,
            clipChunks: []
        };

        // Alert counting for exam termination
        let totalAlertCount = 0;
        let lastAlertTime = 0;
        const ALERT_COOLDOWN = 5000; // 5 seconds between counting alerts
        let examTerminated = false; // Flag to prevent multiple terminations

        // Initialize exam with session data
        async function initExam() {
            // Get exam ID from URL
            const pathParts = window.location.pathname.split('/');
            examState.examId = pathParts[pathParts.length - 1];
            examState.userId = sessionStorage.getItem('userId');

            // Check if exam was already taken
            try {
                const userResponse = await fetch(`/select?collection=users&id=${examState.userId}`);
                const userData = await userResponse.json();
                
                if (userData.exams_taken && userData.exams_taken.includes(examState.examId)) {
                    alert('You have already taken this exam');
                    window.location.href = '/student_dashboard';
                    return;
                }

                // Load exam data
                const examResponse = await fetch(`/select?collection=exams&id=${examState.examId}`);
                const examData = await examResponse.json();

                document.getElementById('examTitle').textContent = examData.title;
                document.getElementById('examSubject').textContent = `Subject: ${examData.subject}`;
                
                // Store exam questions and answers for speech detection
                examState.questions = examData.questions.map(q => q.text.toLowerCase());
                examState.allAnswers = [];
                examData.questions.forEach(q => {
                    examState.allAnswers.push(q.correctAnswer.toLowerCase());
                    q.wrongAnswers.forEach(ans => {
                        examState.allAnswers.push(ans.toLowerCase());
                    });
                });
                
                const container = document.getElementById('questionsContainer');
                examData.questions.forEach((q, idx) => {
                    const answers = [q.correctAnswer, ...q.wrongAnswers].sort(() => Math.random() - 0.5);
                    
                    const questionHtml = `
                        <div class="question-card">
                            <h5>Question ${idx + 1}</h5>
                            <p>${q.text}</p>
                            <div class="answers">
                                ${answers.map((answer, i) => `
                                    <div class="answer-option" onclick="selectAnswer(${idx}, ${i}, this)">
                                        ${answer}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    container.innerHTML += questionHtml;
                });

                startTimer(examData.duration * 60);

            } catch (err) {
                console.error('Error initializing exam:', err);
                alert('Error loading exam');
                window.location.href = '/student_dashboard';
            }
        }

        // Timer functionality
        function startTimer(duration) {
            let timer = duration;
            const timerEl = document.getElementById('examTimer');
            
            const countdown = setInterval(() => {
                const minutes = Math.floor(timer / 60);
                const seconds = timer % 60;
                
                timerEl.textContent = `Time Left: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                if (--timer < 0) {
                    clearInterval(countdown);
                    submitExam();
                }
            }, 1000);
        }

        // Handle answer selection
        function selectAnswer(questionIdx, answerIdx, element) {
            examState.answers[questionIdx] = answerIdx;
            const questionCard = element.closest('.question-card');
            questionCard.querySelectorAll('.answer-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            element.classList.add('selected');
            
            // Touch feedback for mobile
            if (window.TouchEvent || 'ontouchstart' in window) {
                element.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    element.style.transform = '';
                }, 150);
            }
        }
        
        // Add touch event support for better mobile interaction
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            document.addEventListener('DOMContentLoaded', function() {
                // Improve touch feedback for answer options
                document.addEventListener('touchstart', function(e) {
                    const answerOption = e.target.closest('.answer-option');
                    if (answerOption) {
                        answerOption.style.opacity = '0.7';
                    }
                }, { passive: true });
                
                document.addEventListener('touchend', function(e) {
                    const answerOption = e.target.closest('.answer-option');
                    if (answerOption) {
                        answerOption.style.opacity = '';
                    }
                }, { passive: true });
            });
        }

        // Submit exam
        async function submitExam() {
            if (examState.submitted) {
                alert('Exam already submitted');
                return;
            }

            const answers = [];
            document.querySelectorAll('.question-card').forEach(card => {
                const selected = card.querySelector('.answer-option.selected');
                answers.push(selected ? selected.textContent.trim() : null);
            });
            
            examState.answers = answers;
            examState.submitted = true;

            try {
                // stop & finalize recording if running (upload handled in onstop)
                if (window.mediaRecorder && window.mediaRecorder.state !== 'inactive') {
                    try { window.mediaRecorder.stop(); } catch(e) { console.warn('stop mediaRecorder failed', e); }
                }

                // wait for video upload to finish (if any)
                if (alertsSession.videoUploadPromise) {
                    try { await alertsSession.videoUploadPromise; } catch(e) { console.warn('video upload failed', e); }
                }

                // Update user's exam history - mark as taken even if terminated to block retakes
                const userResponse = await fetch(`/select?collection=users&id=${examState.userId}`);
                const userData = await userResponse.json();
                const currentExams = userData.exams_taken || [];
                if (!currentExams.includes(examState.examId)) {
                    currentExams.push(examState.examId);
                }

                const updateResponse = await fetch(`/edit/${examState.userId}?collection=users`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        exams_taken: currentExams
                    })
                });

                if (!updateResponse.ok) {
                    console.error('Failed to update user exams_taken');
                }

                // Save exam results using backend endpoint
                await fetch('/add?collection=exam_results', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: examState.userId,
                        exam_id: examState.examId,
                        answers: examState.answers,
                        timestamp: new Date().toISOString(),
                        terminated: !!examState.terminated,
                        forced_score: examState.forceZeroScore ? 0 : undefined
                    })
                });

                // Close proctoring session
                if (alertsSession.sessionId) {
                    await fetch(`/edit/${alertsSession.sessionId}?collection=proctoring_sessions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            flags: alertsSession.flags,
                            end_time: new Date().toISOString(),
                            status: 'completed'
                        })
                    });
                }

                // Log final flags from backend detection
                if (alertsSession.sessionId) {
                    try {
                        const sessionData = await fetch(`/select?collection=proctoring_sessions&id=${alertsSession.sessionId}`);
                        const session = await sessionData.json();
                        if (session.flags) {
                            for (const [flagType, flagList] of Object.entries(session.flags)) {
                                flagList.forEach(flag => {
                                    alertsSession.flags[flagType] = alertsSession.flags[flagType] || [];
                                    alertsSession.flags[flagType].push(flag);
                                });
                            }
                        }
                    } catch (e) {
                        console.warn('Failed to fetch final flags:', e);
                    }
                }

                alert('Exam submitted successfully! You will be redirected to your dashboard.');
                // Clear any cached data and redirect
                sessionStorage.removeItem('examData');
                window.location.href = '/student_dashboard';

            } catch (err) {
                console.error('Error submitting exam:', err);
                alert('Error submitting exam. Please try again.');
            }
        }

        // Modified initAlertsSession function
        async function initAlertsSession() {
            // Verify authentication before creating session
            if (!examState.userId || !sessionStorage.getItem('userId')) {
                console.error('Cannot create proctoring session: User not authenticated');
                return;
            }

            try {
                const response = await fetch('/add?collection=proctoring_sessions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: examState.userId,
                        exam_id: examState.examId,
                        start_time: new Date().toISOString(),
                        status: 'active',
                        flags: {
                            face_absent: [],
                            twofaces: [],
                            loud_sound: [],
                            phone: [],
                            fullscreen_exit: [],
                            keyboard_shortcut: [],
                            right_click: [],
                            tab_switch: [],
                            captions: []
                        }
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to create proctoring session');
                }
                
                const data = await response.json();
                alertsSession.sessionId = data.id;
                alertsSession.userId = examState.userId;
                alertsSession.examId = examState.examId;
            } catch (err) {
                console.error('Error creating proctoring session:', err);
            }
        }

        // Function to start recording a 5-second clip when cheating is detected
        async function startCheatingClip() {
            if (alertsSession.clipRecorded || !window.mediaRecorder) return;

            try {
                alertsSession.clipChunks = [];
                alertsSession.clipRecorder = new MediaRecorder(window.mediaRecorder.stream, {
                    mimeType: window.mediaRecorder.mimeType,
                    bitsPerSecond: 2000000
                });

                alertsSession.clipRecorder.ondataavailable = (ev) => {
                    if (ev.data && ev.data.size > 0) {
                        alertsSession.clipChunks.push(ev.data);
                    }
                };

                alertsSession.clipRecorder.onstop = async () => {
                    const clipBlob = new Blob(alertsSession.clipChunks, { type: alertsSession.clipRecorder.mimeType });
                    alertsSession.clipChunks = [];

                    const fd = new FormData();
                    fd.append('video', clipBlob, `cheating_clip_${alertsSession.sessionId}_${Date.now()}.webm`);

                    try {
                        const response = await fetch(`/upload_video?session_id=${encodeURIComponent(alertsSession.sessionId)}&type=clip`, {
                            method: 'POST',
                            body: fd
                        });
                        if (response.ok) {
                            alertsSession.clipRecorded = true;
                            console.log('Cheating clip uploaded successfully');
                        }
                    } catch (e) {
                        console.error('Failed to upload cheating clip:', e);
                    }
                };

                alertsSession.clipRecorder.start();
                setTimeout(() => {
                    if (alertsSession.clipRecorder && alertsSession.clipRecorder.state === 'recording') {
                        alertsSession.clipRecorder.stop();
                    }
                }, 5000); // Record for 5 seconds

            } catch (e) {
                console.warn('Failed to start cheating clip recording:', e);
            }
        }

        // Security features: tab switch detection, fullscreen locking, copy-paste prevention
        async function initSecurityFeatures() {
            // Enter fullscreen mode - try harder on mobile
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            try {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    await elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) { // Safari
                    await elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { // IE11
                    await elem.msRequestFullscreen();
                } else if (isMobile && elem.webkitEnterFullscreen) { // iOS specific
                    await elem.webkitEnterFullscreen();
                }
            } catch (err) {
                console.warn('Fullscreen request failed:', err);
                if (isMobile) {
                    // On mobile, don't block the exam if fullscreen fails initially
                    alert('Fullscreen mode is recommended for this exam. Please rotate to landscape and allow fullscreen when prompted.');
                } else {
                    alert('Fullscreen mode is required for this exam. Please allow fullscreen and refresh the page.');
                    return;
                }
            }

            // Prevent exiting fullscreen
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);

            // Tab switch detection (with 3s grace handled in visibilitychange)
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            // Window blur/focus detection (catches Alt+Tab, clicking outside window, etc.) with 3s grace
            let windowBlurTime = null;
            window.addEventListener('blur', () => {
                windowBlurTime = Date.now();
            });
            
            window.addEventListener('focus', () => {
                if (windowBlurTime) {
                    const awayMs = Date.now() - windowBlurTime;
                    if (awayMs >= 3000) {
                        registerTabSwitch(awayMs);
                    }
                }
                windowBlurTime = null;
            });

            // Window resize detection (flag resizing attempts)
            let lastSize = { w: window.innerWidth, h: window.innerHeight };
            let resizeTimer = null;
            window.addEventListener('resize', () => {
                if (resizeTimer) clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    const deltaW = Math.abs(window.innerWidth - lastSize.w);
                    const deltaH = Math.abs(window.innerHeight - lastSize.h);
                    if (deltaW > 50 || deltaH > 50) {
                        logAlert('resize_window', `Window resized (${deltaW}px x ${deltaH}px change)`);
                        showExamAlert('‚ö†Ô∏è Resizing the window is not allowed during the exam.');
                    }
                    lastSize = { w: window.innerWidth, h: window.innerHeight };
                }, 400);
            });

            // Copy-paste prevention
            disableCopyPaste();

            console.log('Security features initialized');
        }

        function handleFullscreenChange() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement &&
                !document.mozFullScreenElement && !document.msFullscreenElement) {
                // User exited fullscreen - flag as cheating
                logAlert('fullscreen_exit', 'User exited fullscreen mode');
                alert('Fullscreen mode is required. Please return to fullscreen to continue the exam.');
                // Automatically put back to fullscreen mode
                setTimeout(() => {
                    const elem = document.documentElement;
                    if (elem.requestFullscreen) {
                        elem.requestFullscreen();
                    } else if (elem.webkitRequestFullscreen) { // Safari
                        elem.webkitRequestFullscreen();
                    } else if (elem.msRequestFullscreen) { // IE11
                        elem.msRequestFullscreen();
                    }
                }, 1000);
            }
        }

        let tabSwitchCount = 0;
        let lastTabSwitchTime = 0;
        let hiddenStartTime = null;

        function handleVisibilityChange() {
            if (document.hidden) {
                hiddenStartTime = Date.now();
            } else {
                // User came back; measure how long they were away
                if (hiddenStartTime) {
                    const awayMs = Date.now() - hiddenStartTime;
                    hiddenStartTime = null;
                    if (awayMs >= 3000) { // only flag if away > 3s
                        registerTabSwitch(awayMs);
                    }
                }
            }
        }

        function registerTabSwitch(awayMs) {
            const now = Date.now();
            // additional debounce to avoid double count between visibility/blur handlers
            if (now - lastTabSwitchTime > 500) {
                tabSwitchCount++;
                lastTabSwitchTime = now;
                logAlert('tab_switch', `User left quiz window for ${Math.round(awayMs/1000)}s (count: ${tabSwitchCount})`);
                if (tabSwitchCount >= 3) {
                    showExamAlert(`‚ö†Ô∏è Warning: You have left the quiz window ${tabSwitchCount} times. Continued switching may terminate the exam.`);
                }
            }
        }

        function disableCopyPaste() {
            // Disable right-click context menu
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                logAlert('right_click', 'Right-click attempted');
                showExamAlert('‚ö†Ô∏è Right-click is disabled during the exam.');
                return false;
            }, true);

            // Also prevent right-click on specific elements
            document.addEventListener('mousedown', (e) => {
                if (e.button === 2) { // Right mouse button
                    e.preventDefault();
                    logAlert('right_click', 'Right-click attempted (mousedown)');
                    return false;
                }
            }, true);

            // Disable text selection on entire page during exam
            document.addEventListener('selectstart', (e) => {
                e.preventDefault();
                return false;
            });

            // Disable drag
            document.addEventListener('dragstart', (e) => {
                e.preventDefault();
                return false;
            });

            // Disable text selection on questions
            const questionContainer = document.getElementById('questionsContainer');
            if (questionContainer) {
                questionContainer.style.userSelect = 'none';
                questionContainer.style.webkitUserSelect = 'none';
                questionContainer.style.MozUserSelect = 'none';
                questionContainer.style.msUserSelect = 'none';
            }

            // Prevent keyboard shortcuts - comprehensive list
            document.addEventListener('keydown', (e) => {
                let shortcutDetected = false;
                let shortcutName = '';

                // Ctrl/Cmd combinations
                if (e.ctrlKey || e.metaKey) {
                    const key = e.key.toLowerCase();
                    
                    // Copy, Paste, Cut, Select All
                    if (key === 'c' || key === 'v' || key === 'x' || key === 'a') {
                        shortcutDetected = true;
                        shortcutName = `Ctrl+${key.toUpperCase()}`;
                    }
                    // Save (Ctrl+S)
                    else if (key === 's') {
                        shortcutDetected = true;
                        shortcutName = 'Ctrl+S';
                    }
                    // Print (Ctrl+P)
                    else if (key === 'p') {
                        shortcutDetected = true;
                        shortcutName = 'Ctrl+P';
                    }
                    // Find (Ctrl+F)
                    else if (key === 'f') {
                        shortcutDetected = true;
                        shortcutName = 'Ctrl+F';
                    }
                    // View Source (Ctrl+U)
                    else if (key === 'u') {
                        shortcutDetected = true;
                        shortcutName = 'Ctrl+U';
                    }
                    // Reload (Ctrl+R, Ctrl+Shift+R)
                    else if (key === 'r') {
                        shortcutDetected = true;
                        shortcutName = e.shiftKey ? 'Ctrl+Shift+R' : 'Ctrl+R';
                    }
                    // New Tab (Ctrl+T)
                    else if (key === 't') {
                        shortcutDetected = true;
                        shortcutName = 'Ctrl+T';
                    }
                    // Close Tab (Ctrl+W)
                    else if (key === 'w') {
                        shortcutDetected = true;
                        shortcutName = 'Ctrl+W';
                    }
                    // Developer Tools (Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+Shift+C)
                    else if (e.shiftKey && (key === 'i' || key === 'j' || key === 'c')) {
                        shortcutDetected = true;
                        shortcutName = `Ctrl+Shift+${key.toUpperCase()}`;
                    }
                }
                
                // Function keys
                else if (e.key.startsWith('F')) {
                    // Block F12 (Developer Tools), F5 (Refresh), etc.
                    if (['F12', 'F5', 'F11'].includes(e.key)) {
                        shortcutDetected = true;
                        shortcutName = e.key;
                    }
                }
                
                // Print Screen
                else if (e.key === 'PrintScreen' || (e.keyCode === 44)) {
                    shortcutDetected = true;
                    shortcutName = 'Print Screen';
                }
                
                // Alt+Tab detection (system shortcut, can't be prevented but can be detected)
                else if (e.altKey && e.key === 'Tab') {
                    shortcutDetected = true;
                    shortcutName = 'Alt+Tab';
                }

                // Escape key (prevent closing dialogs or exiting)
                else if (e.key === 'Escape') {
                    // Allow escape only for closing modals, but log it
                    if (!document.getElementById('permissionModal') ||
                        document.getElementById('permissionModal').style.display === 'none') {
                        shortcutDetected = true;
                        shortcutName = 'Escape';
                    }
                }

                if (shortcutDetected) {
                    e.preventDefault();
                    e.stopPropagation();
                    logAlert('keyboard_shortcut', `Keyboard shortcut attempted: ${shortcutName}`);
                    showExamAlert(`‚ö†Ô∏è Keyboard shortcut blocked: ${shortcutName}`);
                    return false;
                }
            }, true);

            // Prevent Ctrl+Shift+Delete (Clear browsing data)
            document.addEventListener('keyup', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Delete') {
                    e.preventDefault();
                    logAlert('keyboard_shortcut', 'Keyboard shortcut attempted: Ctrl+Shift+Delete');
                    showExamAlert('‚ö†Ô∏è Keyboard shortcut blocked: Ctrl+Shift+Delete');
                    return false;
                }
            }, true);
        }

        // Check if speech contains exam questions or answers
        // Track last detection to prevent spam
        let lastExamContentDetection = 0;
        const EXAM_CONTENT_COOLDOWN = 3000; // 3 seconds between detections

        function checkForExamContent(transcript) {
            if (!examState.questions || examState.questions.length === 0) return;
            
            const transcriptLower = transcript.toLowerCase().trim();
            if (transcriptLower.length < 3) return; // Skip very short transcripts
            
            let examContentDetected = false;
            let detectedType = '';
            let detectedContent = '';
            
            // Check for exam questions - improved matching
            for (let i = 0; i < examState.questions.length; i++) {
                const question = examState.questions[i].toLowerCase();
                // Extract meaningful words (longer than 3 characters)
                const questionWords = question.split(' ').filter(w => w.length > 3);
                
                // Check if at least 3 key words from question appear in transcript
                const matchingWords = questionWords.filter(word => transcriptLower.includes(word));
                if (matchingWords.length >= 3) {
                    examContentDetected = true;
                    detectedType = 'question';
                    detectedContent = `Question ${i + 1}: "${question.substring(0, 60)}..."`;
                    break;
                }
            }
            
            // Check for exam answers - improved matching
            if (!examContentDetected) {
                for (let answer of examState.allAnswers) {
                    const answerLower = answer.toLowerCase().trim();
                    const answerWords = answerLower.split(' ');
                    
                    if (answerWords.length >= 3) {
                        // For longer answers, check if at least 2-3 key words match
                        const keyWords = answerWords.filter(w => w.length > 3).slice(0, 4);
                        if (keyWords.length >= 2) {
                            const matchingWords = keyWords.filter(word => transcriptLower.includes(word));
                            if (matchingWords.length >= 2) {
                                examContentDetected = true;
                                detectedType = 'answer';
                                detectedContent = `Answer: "${answer.substring(0, 50)}..."`;
                                break;
                            }
                        }
                    } else if (answerWords.length > 0) {
                        // For short answers, check if the full answer or significant part appears
                        if (transcriptLower.includes(answerLower) || 
                            (answerLower.length > 5 && transcriptLower.includes(answerLower.substring(0, Math.floor(answerLower.length * 0.7))))) {
                            examContentDetected = true;
                            detectedType = 'answer';
                            detectedContent = `Answer: "${answer}"`;
                            break;
                        }
                    }
                }
            }
            
            // If exam content detected, log as cheating alert (with cooldown)
            if (examContentDetected) {
                const now = Date.now();
                if (now - lastExamContentDetection > EXAM_CONTENT_COOLDOWN) {
                    lastExamContentDetection = now;
                    
                    const alertMessage = `üö® CHEATING DETECTED: Student is reading ${detectedType} from exam! (${detectedContent})`;
                    logAlert('captions', alertMessage);
                    showExamAlert(alertMessage);
                    
                    // Highlight captions in red to show it's a violation
                    const captionsElement = document.getElementById('captions');
                    if (captionsElement) {
                        captionsElement.style.background = 'rgba(255,80,80,0.4)';
                        captionsElement.style.border = '2px solid rgba(255,80,80,0.9)';
                        captionsElement.style.color = '#ffb3b3';
                        captionsElement.style.fontWeight = 'bold';
                        setTimeout(() => {
                            if (captionsElement) {
                                captionsElement.style.background = 'rgba(0,0,0,0.5)';
                                captionsElement.style.border = 'none';
                                captionsElement.style.color = '#e6eef8';
                                captionsElement.style.fontWeight = 'normal';
                            }
                        }, 5000);
                    }
                    
                    console.warn('EXAM CONTENT DETECTED IN SPEECH:', detectedType, detectedContent);
                }
            }
        }

        // Update student Alert Distribution panel
        function updateStudentAlertDistribution(type) {
            const idMap = {
                twofaces:          'student-alert-twofaces',
                loud_sound:        'student-alert-loud-sound',
                phone:             'student-alert-phone',
                fullscreen_exit:   'student-alert-fullscreen-exit',
                keyboard_shortcut: 'student-alert-keyboard-shortcut',
                right_click:       'student-alert-right-click',
                tab_switch:        'student-alert-tab-switch',
                captions:          'student-alert-captions',
                face_absent:       'student-alert-face-absent'
            };

            const elId = idMap[type];
            if (!elId) return;

            const badge = document.getElementById(elId);
            if (!badge) return;

            const current = parseInt(badge.textContent || '0', 10);
            badge.textContent = current + 1;
            
            // Add animation effect when count updates
            badge.style.transform = 'scale(1.2)';
            setTimeout(() => {
                badge.style.transform = 'scale(1)';
            }, 200);
        }

        // Helper to terminate exam with zero score
        function terminateExam(message) {
            if (examState.terminated) return;
            examState.terminated = true;
            examState.forceZeroScore = true;
            showExamAlert(message);
            setTimeout(() => {
                submitExam();
            }, 1500);
        }

        // Per-violation thresholds
        const VIOLATION_LIMITS = {
            phone: 1,
            twofaces: 3,
            loud_sound: 3,
            fullscreen_exit: 3,
            keyboard_shortcut: 3,
            right_click: 3,
            tab_switch: 3,
            face_absent: 3,
        };

        // Cooldown to avoid double-counting rapid duplicate events
        const TYPE_COOLDOWN_MS = 2000;
        // Per-type pause window after a violation (prevents continuous increments, e.g., face_absent)
        const PER_TYPE_PAUSE_MS = 5000;
        const lastPerTypeAlertTime = {};
        const perTypeBlockUntil = {};

        // Modify logAlert function to update immediately and trigger clip recording
        async function logAlert(type, message) {
            if (!alertsSession.sessionId) return;

            const now = Date.now();

            // If this type is currently in a pause window, ignore
            if (perTypeBlockUntil[type] && now < perTypeBlockUntil[type]) {
                return;
            }

            // Debounce per type to prevent double-counting rapid duplicate events
            if (lastPerTypeAlertTime[type] && (now - lastPerTypeAlertTime[type] < TYPE_COOLDOWN_MS)) {
                return; // ignore duplicate within cooldown
            }
            lastPerTypeAlertTime[type] = now;

            // Add timestamp to local flags array
            alertsSession.flags[type].push({
                timestamp: new Date().toISOString(),
                message: message
            });

            const perTypeCount = alertsSession.flags[type].length;

            // Update student Alert Distribution panel
            updateStudentAlertDistribution(type);

            // Start cheating clip recording if not already recorded
            if (!alertsSession.clipRecorded && (type === 'phone' || type === 'twofaces' || type === 'loud_sound' || type === 'face_absent')) {
                startCheatingClip();
            }

            // Per-type enforcement with thresholds
            const limit = VIOLATION_LIMITS[type];
            if (limit) {
                if (type === 'phone') {
                    // Immediate termination on first phone detection
                    terminateExam('üö® PHONE DETECTED: Exam terminated immediately. Your exam will be marked as incomplete (0 points).');
                } else if (perTypeCount >= limit) {
                    terminateExam(`üö® THIRD VIOLATION (${type}): Exam terminated. Marked as incomplete (0 points).`);
                } else if (perTypeCount === 2) {
                    // Second violation of this type: pause
                    showExamAlert(`üö® SECOND ${type.toUpperCase()} VIOLATION: Exam paused for 5 seconds.`);
                    perTypeBlockUntil[type] = Date.now() + PER_TYPE_PAUSE_MS;
                    const examContainer = document.getElementById('examContainer');
                    if (examContainer) {
                        examContainer.style.pointerEvents = 'none';
                        examContainer.style.opacity = '0.5';
                    }
                    setTimeout(() => {
                        if (examContainer) {
                            examContainer.style.pointerEvents = 'auto';
                            examContainer.style.opacity = '1';
                        }
                        showExamAlert('Exam resumed. Please continue taking your exam.');
                    }, PER_TYPE_PAUSE_MS);
                } else if (perTypeCount === 1) {
                    // First violation: pause then resume
                    showExamAlert(`‚ö†Ô∏è FIRST ${type.replace('_', ' ').toUpperCase()} VIOLATION: Exam paused for 5 seconds.`);
                    perTypeBlockUntil[type] = Date.now() + PER_TYPE_PAUSE_MS;
                    const examContainer = document.getElementById('examContainer');
                    if (examContainer) {
                        examContainer.style.pointerEvents = 'none';
                        examContainer.style.opacity = '0.5';
                    }
                    setTimeout(() => {
                        if (examContainer) {
                            examContainer.style.pointerEvents = 'auto';
                            examContainer.style.opacity = '1';
                        }
                        showExamAlert('Exam resumed. Please continue taking your exam.');
                    }, PER_TYPE_PAUSE_MS);
                }
            }

            // Update database immediately
            try {
                await fetch(`/edit/${alertsSession.sessionId}?collection=proctoring_sessions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        flags: alertsSession.flags
                    })
                });
            } catch (err) {
                console.error('Error updating alerts:', err);
            }
        }

        // Permission handling
        let permissionsGranted = false;

        async function requestPermissions() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: 1280, height: 720 },
                    audio: true
                });

                // Stop the test stream
                stream.getTracks().forEach(track => track.stop());

                permissionsGranted = true;
                document.getElementById('permissionModal').style.display = 'none';
                document.getElementById('examContainer').style.display = 'flex';

                // Now start the exam
                await startExam();

            } catch (err) {
                alert('Camera and microphone access are required to take this exam. Please allow access and try again.');
                console.error('Permission denied:', err);
            }
        }

        function denyPermissions() {
            alert('Camera and microphone access are required to take this exam. Please refresh the page and allow access.');
        }

        // Start exam after permissions granted
        async function startExam() {
            try {
                await initExam();
                await initAlertsSession();
                await initModels();
                await initSecurityFeatures(); // Add security features
            } catch(err) {
                labelDiv.innerText = 'Initialization error: '+ (err && err.message ? err.message : String(err));
                return;
            }
            // Keep existing detection initialization
        }

        // Start exam when page loads
        window.addEventListener('load', () => {
            // Show permission modal first
            document.getElementById('permissionModal').style.display = 'flex';
        });
    </script>
    
    <!-- Keep existing detection script -->
    <script>
        // Elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const labelDiv = document.getElementById('label');
        const processedImg = document.getElementById('processed');
        const barFill = document.getElementById('barFill');
        const probText = document.getElementById('probText');

        // Captions elements
        const captionsEl = document.getElementById('captions');

       // Alert elements
        const alertNoFace = document.getElementById('alert-noface');
        const alertTwoFaces = document.getElementById('alert-multiplefaces');
        const alertPhone = document.getElementById('alert-phone');
        const alertLoudSound = document.getElementById('alert-loudsound');

        const alertMVoices = document.getElementById('alert-mvoices');

        // Mic UI
        const micFillEl = document.getElementById('micFill');
        const micStatus = document.getElementById('micStatus');

        function setAlert(el, on, text){
            if(!el) return;
            if(on){
                if(text) el.textContent = text;
                el.classList.add('show');
            } else {
                el.classList.remove('show');
            }
        }

        // Debug helpers
        window.addEventListener('error', (e) => {
            console.error('Window error', e);
            try { labelDiv.innerText = 'Error: ' + (e.message || e.error || e); } catch {}
        });
        window.addEventListener('unhandledrejection', (ev) => {
            console.error('Unhandled rejection', ev);
            try { labelDiv.innerText = 'Promise error: ' + (ev.reason && ev.reason.message ? ev.reason.message : String(ev.reason)); } catch {}
        });

        labelDiv.innerText = 'Initializing and auto-starting...';

        let useFront = true;
        let running = false;
        let sendInterval = null;
        // Server-side processing interval (ms)
        // For Render free tier: Use 5000-10000ms (5-10 seconds) to avoid overload
        // For paid hosting: Can use 500-1000ms (0.5-1 second) for real-time detection
        // Set to 0 to disable server-side processing entirely (use client-side only)
        let intervalMs = 5000; // Default: 5 seconds (optimized for Render free tier)

        // Mobile performance optimizations
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let frameCount = 0;
        let lastProcessedTime = 0;
        const targetFPS = isMobile ? 10 : 20; // Lower FPS on mobile
        const frameInterval = 1000 / targetFPS;

        // Models
        let cocoModel = null;
        let faceMesh = null;
        let camera = null;

        const detCanvas = document.createElement('canvas');
        const detCtx = detCanvas.getContext('2d');
        const DET_W = 640;
        const DET_H = 360;
        detCanvas.width = DET_W;
        detCanvas.height = DET_H;

        async function initModels(){
            labelDiv.innerText = 'Loading models...';
            try {
                cocoModel = await cocoSsd.load();
            } catch (e) {
                console.warn('coco load failed', e);
                cocoModel = null;
            }
            try {
                faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                });
                faceMesh.setOptions({
                    maxNumFaces: 4,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                faceMesh.onResults(onFaceResults);
            } catch (e) {
                console.error('faceMesh init failed', e);
                throw e;
            }
            labelDiv.innerText = 'Models loaded';
        }

        function stopTracks(stream){
            try{
                if(!stream) return;
                stream.getTracks().forEach(t => { try{ t.stop(); }catch(e){} });
            }catch(e){}
        }

        async function startCameraStream() {
            try {
                // Add timeout promise
                const streamPromise = navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: useFront ? 'user' : 'environment',
                        width: 640,
                        height: 360
                    }
                });
                
                const stream = await Promise.race([
                    streamPromise,
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Camera permission timeout')), 10000))
                ]);

                if(video.srcObject) {
                    stopTracks(video.srcObject);
                }
                video.srcObject = stream;
                await video.play();
                
                // Initialize camera after successful stream
                camera = new Camera(video, {
                    onFrame: async () => {
                        const now = performance.now();
                        if (now - lastProcessedTime >= frameInterval) {
                            lastProcessedTime = now;
                            frameCount++;
                            if(faceMesh) await faceMesh.send({image: video});
                        }
                    },
                    width: 640,
                    height: 360
                });
                camera.start();

            } catch(err) {
                labelDiv.innerText = 'Camera error: ' + (err.message || err);
                console.error('Camera start failed:', err);
                // Add retry button
                const retryBtn = document.createElement('button');
                retryBtn.innerText = 'Retry Camera';
                retryBtn.onclick = startCameraStream;
                labelDiv.appendChild(retryBtn);
            }
        }

        // gaze estimator (unchanged)
        function estimateGazeFromLandmarks(landmarks){
            if(!landmarks || landmarks.length === 0) return {looking:false, yaw:0, pitch:0};
            const leftOuter = landmarks[33];
            const rightOuter = landmarks[263];
            const eyeCenter = { x: (leftOuter.x + rightOuter.x) / 2, y: (leftOuter.y + rightOuter.y) / 2 };
            const faceWidth = Math.abs(rightOuter.x - leftOuter.x) + 1e-6;
            let leftIrisCenter = null, rightIrisCenter = null;
            if(landmarks.length > 468){
                const li = [468,469,470,471].map(i=>landmarks[i]);
                const ri = [473,474,475,476].map(i=>landmarks[i]);
                leftIrisCenter = li.reduce((acc,p)=>({x:acc.x+p.x,y:acc.y+p.y}), {x:0,y:0});
                rightIrisCenter = ri.reduce((acc,p)=>({x:acc.x+p.x,y:acc.y+p.y}), {x:0,y:0});
                leftIrisCenter.x /= li.length; leftIrisCenter.y /= li.length;
                rightIrisCenter.x /= ri.length; rightIrisCenter.y /= ri.length;
            }
            let yaw = 0, pitch = 0;
            if(leftIrisCenter && rightIrisCenter){
                const irisCenter = { x: (leftIrisCenter.x + rightIrisCenter.x)/2, y: (leftIrisCenter.y + rightIrisCenter.y)/2 };
                yaw = (irisCenter.x - eyeCenter.x) / faceWidth;
                pitch = (irisCenter.y - eyeCenter.y) / faceWidth;
            }else{
                const nose = landmarks[1];
                yaw = (nose.x - eyeCenter.x) / faceWidth;
                pitch = (nose.y - eyeCenter.y) / faceWidth;
            }
            const absYaw = Math.abs(yaw);
            const absPitch = Math.abs(pitch);
            const yawThresh = 0.18;
            const pitchUpThresh = 0.20;
            const pitchDownThresh = 0.24;
            const looking = (absYaw < yawThresh) && (pitch > -pitchUpThresh) && (pitch < pitchDownThresh);
            
            return { looking, yaw, pitch };
        }

        async function onFaceResults(results){
            const faces = results.multiFaceLandmarks || [];

            // Skip processing if no faces and we're on mobile (reduce CPU usage)
            if (isMobile && faces.length === 0 && frameCount % 3 !== 0) {
                return;
            }

            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            let lookingCount = 0;
            faces.forEach((landmarks, idx) => {
                drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, {color: '#6ee7b7', lineWidth: 0.5});
                drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, {color: '#6ee7b7'});
                drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, {color: '#6ee7b7'});

                const gaze = estimateGazeFromLandmarks(landmarks);
                if(gaze.looking) lookingCount++;

                const x = landmarks[1].x * canvas.width;
                const y = (landmarks[10].y * canvas.height) - 8;
                ctx.fillStyle = gaze.looking ? 'rgba(0,200,80,0.95)' : 'rgba(255,80,80,0.95)';
                ctx.font = '16px Inter, sans-serif';
                ctx.fillText(`${gaze.looking ? 'LOOKING' : 'NOT'}`, x, y);
            });

            let phoneDetections = [];
            // Reduce object detection frequency on mobile to improve performance
            if(cocoModel && (!isMobile || frameCount % 5 === 0)){
                try{
                    detCtx.clearRect(0,0,DET_W,DET_H);
                    detCtx.drawImage(video, 0, 0, DET_W, DET_H);
                    const detections = await cocoModel.detect(detCanvas, isMobile ? 5 : 10); // Lower threshold on mobile
                    phoneDetections = detections.filter(d => {
                        const cls = String(d.class).toLowerCase();
                        return cls.includes('cell') && cls.includes('phone') || cls === 'cell phone' || cls === 'mobile phone' || cls === 'phone';
                    });
                    phoneDetections.forEach(d => {
                        let [x,y,w,h] = d.bbox;
                        const scaleX = canvas.width / DET_W;
                        const scaleY = canvas.height / DET_H;
                        const rx = x * scaleX, ry = y * scaleY, rw = w * scaleX, rh = h * scaleY;
                        ctx.strokeStyle = '#ff8c42';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(rx, ry, rw, rh);
                        ctx.fillStyle = '#ff8c42';
                        ctx.font = '16px Inter, sans-serif';
                        ctx.fillText(`${d.class} ${(d.score*100).toFixed(0)}%`, rx + 6, ry + 18);
                    });
                }catch(e){
                    console.debug('coco error', e);
                }
            }

            // Alerts logic
            // 0) No face
            if (faces.length === 0) {
                setAlert(alertNoFace, true, 'No face detected!');
                logAlert('face_absent', 'No face detected!');
            } else {
                setAlert(alertNoFace, false);
            }

            // 1) Multiple faces
            if (faces.length >= 2) {
                setAlert(alertTwoFaces, true, `Multiple faces detected (${faces.length})`);
                logAlert('twofaces', `Multiple faces detected (${faces.length})`);
            } else {
                setAlert(alertTwoFaces, false);
            }



            // 3) Phone detected - IMMEDIATE EXAM TERMINATION
            if (phoneDetections.length > 0) {
                setAlert(alertPhone, true, `Phone detected (${phoneDetections.length})`);
                logAlert('phone', `Phone detected (${phoneDetections.length})`);
                if (!examTerminated) {
                    examTerminated = true;
                    examState.terminated = true;
                    totalAlertCount = 1; // Set alert count to 1 for immediate termination
                    showExamAlert('üö® PHONE DETECTED: Exam terminated immediately. Your exam will be marked as incomplete.');
                    setTimeout(() => {
                        submitExam();
                    }, 2000);
                }
            } else {
                setAlert(alertPhone, false);
            }

            labelDiv.innerText = `Faces: ${faces.length} ‚Ä¢ Looking: ${lookingCount} ‚Ä¢ Phones: ${phoneDetections.length}`;
            const p = faces.length ? (lookingCount / faces.length) : 0;
            barFill.style.width = `${Math.round(p*100)}%`;
            probText.innerText = `${Math.round(p*100)}%`;

            // Reduce image quality on mobile for better performance
            const imageQuality = isMobile ? 0.6 : 0.8;
            processedImg.src = canvas.toDataURL('image/jpeg', imageQuality);
        }

        async function sendPreviewToServer(){
            if(!processedImg.src) return;
            
            // Skip if server-side processing is disabled (intervalMs = 0)
            if (intervalMs === 0) return;

            // Reduce server upload frequency on mobile
            if (isMobile && frameCount % 3 !== 0) return;

            try{
                const res = await fetch(processedImg.src);
                const blob = await res.blob();
                const form = new FormData();
                form.append('frame', blob, 'client.jpg');
                const sessionId = alertsSession.sessionId ? `?session_id=${encodeURIComponent(alertsSession.sessionId)}` : '';
                
                // Add timeout for Render free tier (30 second limit)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 25000); // 25 second timeout
                
                try {
                    await fetch(`/predict${sessionId}`, {
                        method:'POST', 
                        body: form,
                        signal: controller.signal
                    });
                } finally {
                    clearTimeout(timeoutId);
                }
            }catch(e){
                // Silently fail to avoid disrupting exam flow
                // Server-side processing is optional (client-side detection still works)
                console.debug('Server-side processing skipped:', e.message);
            }
        }

        // ================= SPEECH RECOGNITION =================
        let recognition = null;
        let captionsClearTimeout = null;

        async function startSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.warn('Speech recognition not supported in this browser');
                micStatus.innerText = 'Speech recognition not supported';
                alert('Speech recognition is not supported in this browser. Please use a compatible browser like Chrome or Safari.');
                return;
            }

            // Check if already running
            if (recognition && (recognition.continuous || recognition.state === 'listening')) {
                console.log('Speech recognition already running');
                return;
            }

            try {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US'; // Can be made configurable

                recognition.onstart = () => {
                    console.log('Speech recognition started');
                    // Show captions area with "Listening..." message
                    const captionsElement = document.getElementById('captions');
                    if (captionsElement) {
                        captionsElement.style.display = 'block';
                        captionsElement.textContent = 'Listening...';
                        console.log('Captions element found and displayed');
                        
                        // Clear "Listening..." after 3 seconds if no speech detected
                        if (captionsClearTimeout) {
                            clearTimeout(captionsClearTimeout);
                        }
                        captionsClearTimeout = setTimeout(() => {
                            if (captionsElement && captionsElement.textContent === 'Listening...') {
                                captionsElement.textContent = '';
                                captionsElement.style.display = 'none';
                            }
                        }, 3000);
                    } else {
                        console.error('Captions element not found!');
                    }
                    if (micStatus) {
                        micStatus.innerText = 'Listening...';
                    }
                };

                recognition.onresult = (event) => {
                    let finalTranscript = '';
                    let interimTranscript = '';

                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript + ' ';
                        } else {
                            interimTranscript += transcript + ' ';
                        }
                    }

                    // Get captions element fresh each time to ensure it exists
                    const captionsElement = document.getElementById('captions');
                    
                    // Clear any existing timeout
                    if (captionsClearTimeout) {
                        clearTimeout(captionsClearTimeout);
                        captionsClearTimeout = null;
                    }
                    
                    // Display captions - show both final and interim results
                    let displayText = '';
                    if (finalTranscript.trim()) {
                        displayText = finalTranscript.trim();
                    }
                    if (interimTranscript.trim()) {
                        displayText = (displayText ? displayText + ' ' : '') + interimTranscript.trim() + '...';
                    }

                    // Update captions if there's any text (interim or final)
                    if (captionsElement) {
                        if (displayText) {
                            captionsElement.style.display = 'block';
                            captionsElement.textContent = displayText;
                            console.log('Speech detected:', displayText);
                            
                            // Set timeout to clear captions after 5 seconds of no new speech
                            captionsClearTimeout = setTimeout(() => {
                                if (captionsElement) {
                                    captionsElement.textContent = '';
                                    captionsElement.style.display = 'none';
                                }
                            }, 5000);
                        } else {
                            // Keep showing "Listening..." if no speech yet
                            captionsElement.style.display = 'block';
                            captionsElement.textContent = 'Listening...';
                        }
                    } else {
                        console.error('Captions element not found in onresult!');
                    }

                    // Check for exam content on both interim and final transcripts
                    const fullTranscript = (finalTranscript + ' ' + interimTranscript).trim();
                    if (fullTranscript) {
                        // Check if speech contains exam questions or answers
                        checkForExamContent(fullTranscript);
                    }

                    // Log final transcripts to alerts session
                    if (finalTranscript.trim()) {
                        if (alertsSession && alertsSession.flags) {
                        alertsSession.flags.captions.push({
                            timestamp: new Date().toISOString(),
                                text: finalTranscript.trim()
                        });
                        }
                        // Update student alert distribution
                        updateStudentAlertDistribution('captions');
                    }
                };

                recognition.onerror = (event) => {
                    console.warn('Speech recognition error:', event.error);

                    // Handle specific error types
                    switch(event.error) {
                        case 'aborted':
                            // Silently retry - aborted is usually normal (user interaction, etc.)
                            setTimeout(() => startSpeechRecognition(), 3000);
                            break;
                        case 'network':
                            // Network error - show warning but don't spam
                            if (micStatus) {
                                micStatus.innerText = 'Network error. Retrying...';
                            }
                            setTimeout(() => startSpeechRecognition(), 5000);
                            break;
                        case 'not-allowed':
                            // Permission denied - show alert once
                            if (micStatus) {
                                micStatus.innerText = 'Microphone permission denied';
                            }
                            console.error('Microphone permission denied for speech recognition');
                            // Don't retry if permission denied
                            break;
                        case 'no-speech':
                            // No speech detected is NORMAL - don't show error message
                            // Just silently restart - this happens when user is quiet
                            setTimeout(() => startSpeechRecognition(), 3000);
                            // Keep captions showing "Listening..." when no speech
                            if (captionsEl) {
                                captionsEl.style.display = 'block';
                                captionsEl.textContent = 'Listening...';
                            }
                            break;
                        case 'audio-capture':
                            // Audio capture failed - show alert once
                            if (micStatus) {
                                micStatus.innerText = 'Audio capture failed';
                            }
                            alert('Audio capture failed. Please check your microphone and refresh the page.');
                            // Don't retry if audio capture failed
                            break;
                        default:
                            // Other errors - silently retry
                            console.warn('Speech recognition error:', event.error, '- retrying...');
                            setTimeout(() => startSpeechRecognition(), 3000);
                    }

                    // Only update captions for errors that should be shown to user
                    if (event.error !== 'no-speech' && event.error !== 'aborted') {
                        if (captionsEl && (event.error === 'network' || event.error === 'audio-capture')) {
                            captionsEl.textContent = 'Error: ' + event.error;
                        }
                    }
                };

                recognition.onend = () => {
                    console.log('Speech recognition ended - restarting silently');
                    // Auto-restart speech recognition silently
                    // This is normal behavior - recognition ends after a timeout and restarts
                    setTimeout(() => {
                        try {
                            startSpeechRecognition();
                        } catch (e) {
                            console.warn('Speech recognition restart failed:', e);
                            if (micStatus) {
                            micStatus.innerText = 'Speech recognition stopped';
                        }
                        }
                    }, 2000);
                };

                recognition.start();
                console.log('Speech recognition start() called');
            } catch (e) {
                console.warn('Failed to start speech recognition:', e);
                const captionsElement = document.getElementById('captions');
                if (captionsElement) {
                    captionsElement.textContent = 'Speech recognition failed to start';
                    captionsElement.style.display = 'block';
                }
                if (micStatus) {
                micStatus.innerText = 'Failed to start speech recognition';
                }
                alert('Failed to start speech recognition. Please refresh the page or use a different browser.');
            }
        }

        // ================= AUDIO (MIC) DETECTION =================
        // Balanced thresholds by default (suitable for classroom)
        let audioCtx = null;
        let analyser = null;
        let micStream = null;
        let micDataArray = null;
        let prevSpec = null;

        async function startMicAnalysis(){
            // request mic access
            try{
                micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            }catch(e){
                micStatus.innerText = 'Microphone blocked';
                console.warn('mic access denied', e);
                return;
            }

            try{
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const src = audioCtx.createMediaStreamSource(micStream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048; // better resolution for voice
                analyser.smoothingTimeConstant = 0.3;
                src.connect(analyser);

                const bufferLength = analyser.frequencyBinCount;
                micDataArray = new Uint8Array(bufferLength);
                prevSpec = new Float32Array(bufferLength);
                micStatus.innerText = 'Listening';
                // analyze loop
                const specFloat = new Float32Array(bufferLength);

                function analyzeAudio(){
                    if(!analyser) return;
                    analyser.getByteFrequencyData(micDataArray);

                    // compute RMS-like loudness from freq bins
                    let sum = 0;
                    for(let i=0;i<bufferLength;i++){
                        const v = micDataArray[i] / 255;
                        sum += v*v;
                    }
                    const rms = Math.sqrt(sum / bufferLength); // 0..1-ish

                    // update mic meter
                    const meterPct = Math.min(1, rms*1.6); // scale so normal talk ~0.35-0.6
                    micFillEl.style.width = `${Math.round(meterPct*100)}%`;
                    micStatus.innerText = `${Math.round(meterPct*100)}%`;

                    // Loud detection thresholds (balanced)
                    // Adjust this value to change sensitivity:
                    // - 0.60 (60%) = very sensitive, detects background noise
                    // - 0.75 (75%) = moderate, detects normal talking
                    // - 0.90 (90%) = less sensitive, mainly shouting
                    // - 0.95+ (95%+) = only very loud sounds
                    const LOUD_THRESHOLD = 0.60; // Set to 0.60 for detecting background noise and normal talking
                    const loudDetected = meterPct > LOUD_THRESHOLD;
                    if (loudDetected) {
                        setAlert(alertLoudSound, true, `Loud sound detected (${Math.round(meterPct*100)}%)`);
                        logAlert('loud_sound', `Loud sound detected (${Math.round(meterPct*100)}%)`);
                    } else {
                        setAlert(alertLoudSound, false);
                    }



                    requestAnimationFrame(analyzeAudio);
                }
                analyzeAudio();
            }catch(e){
                micStatus.innerText = 'Mic error';
                console.error('startMicAnalysis error', e);
            }
        }



        // Auto-start on load: initialize models and immediately start camera + processing + mic
        window.addEventListener('load', async () => {
            try{
                await initModels();
            }catch(err){
                labelDiv.innerText = 'Model load error: '+ (err && err.message ? err.message : String(err));
                return;
            }

            // try to get permission & preview then start full camera processing
            try{
                const constraints = { video: { facingMode: useFront ? 'user' : 'environment', width: 640, height: 360 }, audio: true };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                if(video.srcObject) stopTracks(video.srcObject);
                video.srcObject = stream;
                try{ await video.play(); }catch(e){ console.debug('preview play ignored', e); }

                // start MediaPipe faceMesh + camera stream (this will drive onFaceResults)
                await startCameraStream();

                // start recording the full session (use same stream if available)
                try { startMediaRecorder(stream); } catch(e) { console.warn('startMediaRecorder failed', e); }

                // mic analysis (no sound playback) - always start on all devices
                // Audio detection is essential for proctoring, so we always enable it
                startMicAnalysis().catch(e=>console.warn('mic start failed', e));

                // Start speech recognition with better error handling and longer delays
                const startDelay = isMobile ? 5000 : 1000; // Even longer delay on mobile

                setTimeout(() => {
                    try {
                        startSpeechRecognition();
                    } catch (e) {
                        console.warn('Speech recognition auto-start failed:', e);
                        micStatus.innerText = 'Speech recognition unavailable';
                    }
                }, startDelay);

                // mark running and start periodic send (if desired) - reduce frequency on mobile
                running = true;
                if(sendInterval) clearInterval(sendInterval);
                const sendIntervalMs = isMobile ? intervalMs * 3 : intervalMs; // Send less frequently on mobile
                sendInterval = setInterval(sendPreviewToServer, sendIntervalMs);

            }catch(e){
                labelDiv.innerText = 'Camera preview error: '+ (e.message || e);
                console.error('preview getUserMedia failed', e);
            }
        });

        // expose interval setter
        window.setCaptureInterval = function(ms){
            intervalMs = ms;
            if(sendInterval){
                clearInterval(sendInterval);
                const sendIntervalMs = isMobile ? intervalMs * 3 : intervalMs;
                sendInterval = setInterval(sendPreviewToServer, sendIntervalMs);
            }
        };

        // ----------------- MediaRecorder: record full session and upload -----------------
        window.mediaRecorder = null;
        window.mediaChunks = [];
        // alertsSession.videoUploadPromise will be set when upload starts; resolved when server confirms
        async function startMediaRecorder(stream) {
            if (!stream) return;
            try {
                const mime = (MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' :
                              (MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' : 'video/webm'));
                window.mediaChunks = [];
                window.mediaRecorder = new MediaRecorder(stream, { mimeType: mime, bitsPerSecond: 2000000 });
                window.mediaRecorder.ondataavailable = (ev) => {
                    if (ev.data && ev.data.size > 0) window.mediaChunks.push(ev.data);
                };
                window.mediaRecorder.onstop = async () => {
                    // assemble blob and upload to server
                    const blob = new Blob(window.mediaChunks, { type: mime });
                    window.mediaChunks = [];
                    if (!alertsSession.sessionId) {
                        console.warn('no session id to attach video to');
                        return;
                    }
                    const fd = new FormData();
                    fd.append('video', blob, `session_${alertsSession.sessionId}_${Date.now()}.webm`);
                    // store promise on alertsSession so submitExam can await
                    alertsSession.videoUploadPromise = fetch(`/upload_video?session_id=${encodeURIComponent(alertsSession.sessionId)}`, {
                        method: 'POST',
                        body: fd
                    }).then(async (res) => {
                        if(!res.ok) throw new Error('upload failed');
                        return res.json();
                    }).then((j) => {
                        console.log('video uploaded', j);
                        return j;
                    }).catch(e => { console.error('video upload error', e); throw e; }).finally(() => {
                        // clear reference after finishing
                        alertsSession.videoUploadPromise = null;
                    });
                    return alertsSession.videoUploadPromise;
                };
                window.mediaRecorder.start();
                console.log('MediaRecorder started', mime);
            } catch (e) {
                console.warn('Failed to start MediaRecorder', e);
            }
        }
        

    </script>
</body>
</html>
</html>