<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover,user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0f1724">
    <title>Online Exam with Proctoring</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>

        /* ---------- PROCTORING COLLAPSE ---------- */
.detection-area {
  flex: 0 0 auto;
  transition: height 0.3s ease;
  background: var(--card);
  border-bottom: 1px solid rgba(255,255,255,.1);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  position: relative;
  height: auto;
  /* Optimize for mobile performance */
  will-change: height;
  contain: layout style paint;
}

.proctor-toggle {
  position: absolute;
  top: 8px;
  right: 8px;
  background: var(--accent);
  color: #032;
  border: none;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  font-size: 1.2rem;
  line-height: 1;
  cursor: pointer;
  z-index: 10;
  box-shadow: 0 2px 6px rgba(0,0,0,.3);
  transition: all 0.3s ease;
}

.detection-area.collapsed {
  height: 44px !important;
  border-bottom: none;
}

.detection-area.collapsed #alerts,
.detection-area.collapsed .mic-ui,
.detection-area.collapsed .controls,
.detection-area.collapsed #processed,
.detection-area.collapsed #captions,
.detection-area.collapsed #studentAlertDistribution,
.detection-area.collapsed .proctor-header {
  display: none !important;
}
/* Keep alert distribution visible even when collapsed */


 /* Keep video element hidden but functional when collapsed */
.detection-area.collapsed .media {
  position: absolute;
  opacity: 0;
  pointer-events: none;
  z-index: -1;
}

        .proctor-header {
  padding: 0.6rem 1rem;
  display: flex;
  align-items: center;
  gap: 8px;
  background: rgba(255,255,255,.04);
  border-bottom: 1px solid rgba(255,255,255,.1);
  font-size: 0.9rem;
}

.back-btn {
  background: none;
  border: none;
  color: #e6eef8;
  font-size: 1.2rem;
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.back-btn:hover {
  background: rgba(255,255,255,0.1);
}
        /* Keep existing styles */
        :root{
            --bg:#0f1724;
            --card: rgba(255,255,255,0.06);
            --accent: #6ee7b7;
            --muted: #9aa4b2;
            --radius: 14px;
        }
        
        /* Horizontal layout: proctoring on left, exam on right */
        .exam-container {
            display: flex;
            min-height: 100vh;
            background: var(--bg);
            color: #e6eef8;
            /* Optimize for mobile performance */
            contain: layout style;
        }

        .detection-area {
            flex: 0 0 380px;
            background: var(--card);
            border-right: 1px solid rgba(255,255,255,.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .exam-questions {
            flex: 1;
            padding: 2rem;
            background: var(--card);
            border-left: 1px solid rgba(255,255,255,.1);
            display: flex;
            flex-direction: column;
        }

        .question-card {
            background: var(--card);
            border-radius: var(--radius);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .answer-option {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 0.8rem 1rem;
            margin: 0.5rem 0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .answer-option:hover {
            background: rgba(255,255,255,0.08);
        }

        .answer-option.selected {
            background: rgba(110,231,183,0.1);
            border-color: var(--accent);
        }

        .timer {
            text-align: center;
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 1rem;
            padding: 1rem;
            background: rgba(255,255,255,.05);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,.1);
        }

        /* Keep rest of existing styles */
        html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial; background: linear-gradient(180deg,#071023 0%, #0b2440 100%); color:#e6eef8}
        body{background-color:#0b2440}
        *,*::before,*::after{box-sizing:border-box}
        .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:28px;
            padding-bottom: calc(28px + constant(safe-area-inset-bottom));
            padding-bottom: calc(28px + env(safe-area-inset-bottom));
        }
        .app{width:100%;max-width:760px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:18px;padding:18px;box-shadow:0 10px 30px rgba(2,6,23,0.7);display:grid;grid-template-columns:1fr;gap:18px;align-items:start}
        header.app-header{display:flex;align-items:center;gap:12px}
        .logo{width:48px;height:48px;border-radius:12px;background:linear-gradient(135deg,var(--accent),#4dd0e1);display:flex;align-items:center;justify-content:center;color:#032; font-weight:700}
        .title{font-size:1.05rem;font-weight:600}
        .subtitle{font-size:0.85rem;color:var(--muted);margin-top:4px}

        /* video area */
        .viewer{background:var(--card);border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:10px;align-items:center}
        .media{position:relative;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.04);width:100%}
        video{display:block;width:100%;height:auto;background:#000; /* Optimize for performance */ will-change: transform;}
        /* hide raw camera feed visually ‚Äî MediaPipe still uses the hidden video element */
        .media video{display:none !important}
        #processed{display:block;width:100%;height:auto;object-fit:cover;border-radius:8px; /* Optimize for performance */ will-change: auto;}
        .controls{display:flex;align-items:center;justify-content:space-between;gap:12px;width:100%}
        #label{font-weight:600;font-size:1rem}
        .prob{display:flex;gap:8px;align-items:center}
        .bar{height:10px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;width:140px}
        .bar > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#4dd0e1);width:0%}

        /* minimal: hide sidebar and controls we don't need */
        .sidebar{display:none}
        #toggle{display:none}

        .small{font-size:0.86rem;color:var(--muted)}

        /* Alerts */
        #alerts{width:100%;max-width:760px;display:flex;flex-direction:column;gap:8px;margin-top:6px}
        .alert{display:none;padding:10px 12px;border-radius:10px;font-weight:600;align-items:center;gap:8px}
        .alert.show{display:flex}
        .alert.warn{background:rgba(255,165,0,0.08);color:#ffd59a;border:1px solid rgba(255,165,0,0.12)}
        .alert.danger{background:rgba(255,80,80,0.06);color:#ffb3b3;border:1px solid rgba(255,80,80,0.12)}
        .alert.info{background:rgba(110,231,183,0.04);color:var(--accent);border:1px solid rgba(110,231,183,0.08)}

        /* Mic UI */
        .mic-ui{width:100%;max-width:760px;margin-top:6px;padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px}
        .mic-row{display:flex;align-items:center;gap:12px}
        .mic-label{font-weight:600}
        .mic-meter{flex:1;height:10px;background:rgba(255,255,255,0.04);border-radius:8px;overflow:hidden}
        .mic-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#4dd0e1)}
        .mic-status{font-size:0.86rem;color:var(--muted);min-width:120px;text-align:right}

        /* Student Alert Distribution Panel */
        .student-alert-distribution {
            transition: all 0.3s ease;
        }
        .student-alert-distribution .badge {
            transition: transform 0.2s ease;
        }






        /* Permission Modal Styles */
        .permission-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        .permission-content {
            background: var(--card);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }
        .permission-header h3 {
            margin: 0 0 0.5rem 0;
            color: #e6eef8;
            font-size: 1.5rem;
        }
        .permission-header p {
            margin: 0 0 1.5rem 0;
            color: var(--muted);
            line-height: 1.4;
        }
        .permission-details {
            margin-bottom: 2rem;
        }
        .permission-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background: rgba(255,255,255,0.02);
            border-radius: 8px;
        }
        .permission-icon {
            font-size: 2rem;
            width: 3rem;
            text-align: center;
        }
        .permission-item strong {
            color: #e6eef8;
            display: block;
            margin-bottom: 0.25rem;
        }
        .permission-item p {
            margin: 0;
            color: var(--muted);
            font-size: 0.9rem;
        }
        .permission-buttons {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }
        .permission-buttons .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .permission-buttons .btn-primary {
            background: var(--accent);
            color: #032;
        }
        .permission-buttons .btn-primary:hover {
            background: #4dd0e1;
        }
        .permission-buttons .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e6eef8;
        }
        .permission-buttons .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Mobile adjustments for exam layout */
        @media (max-width: 768px) {
            .exam-container {
                flex-direction: column;
                height: 100vh;
                height: -webkit-fill-available; /* iOS Safari fix */
                overflow: hidden;
            }
            .detection-area {
                flex: 0 0 auto;
                height: auto;
                max-height: 35vh; /* Reduced height for better exam visibility */
                border-right: none;
                border-bottom: 1px solid rgba(255,255,255,.1);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch; /* Smooth iOS scrolling */
            }
            .detection-area.collapsed {
                height: 44px;
                min-height: 44px;
            }
            .detection-area:not(.collapsed) {
                max-height: 35vh;
            }
            .exam-questions {
                flex: 1;
                padding: 1rem;
                border-left: none;
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch; /* Smooth iOS scrolling */
                height: calc(100vh - 35vh - 44px); /* Dynamic height */
                height: calc(-webkit-fill-available - 35vh); /* iOS fix */
                min-height: 0; /* Allow flex shrinking */
            }
            .timer {
                font-size: 1.2rem;
                padding: 0.8rem;
                margin-bottom: 0.5rem;
                position: sticky;
                top: 0;
                background: var(--card);
                z-index: 10;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            }
            .proctor-toggle {
                display: block !important; /* Always show toggle on mobile */
            }
            /* Reduce video size on mobile */
            .media video, #processed {
                max-height: 180px;
                width: 100%;
                object-fit: cover;
            }
            /* Optimize controls for mobile */
            .controls, .mic-ui {
                font-size: 0.85rem;
                padding: 6px;
            }
            /* Touch-friendly answer buttons */
            .answer-option {
                min-height: 48px; /* Minimum touch target for mobile */
                padding: 1rem;
                font-size: 1rem;
                -webkit-tap-highlight-color: rgba(110,231,183,0.3);
                touch-action: manipulation; /* Prevent double-tap zoom */
            }
            .question-card {
                padding: 1rem;
                margin-bottom: 1rem;
            }
            /* Prevent text selection on mobile */
            .exam-questions {
                -webkit-user-select: none;
                user-select: none;
            }
            /* Fix submit button on mobile */
            .submit-btn, .btn {
                min-height: 48px;
                font-size: 1rem;
                padding: 1rem 2rem;
                -webkit-tap-highlight-color: rgba(110,231,183,0.3);
                touch-action: manipulation; /* Prevent double-tap zoom */
            }
            /* Prevent zoom on input focus (iOS) */
            input, textarea, select {
                font-size: 16px !important;
            }
            /* Better touch handling */
            button, .answer-option, .btn {
                touch-action: manipulation;
                -webkit-user-select: none;
                user-select: none;
                cursor: pointer;
            }
            /* Active state for touch feedback */
            .answer-option:active {
                background: rgba(110,231,183,0.2) !important;
                transform: scale(0.98);
            }
            /* Ensure exam questions container is properly scrollable */
            .exam-questions {
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
            }
        }
        
        /* Small mobile devices */
        @media (max-width: 480px) {
            .exam-questions {
                padding: 0.75rem;
            }
            .question-card {
                padding: 0.75rem;
                margin-bottom: 0.75rem;
            }
            .answer-option {
                padding: 0.875rem;
                min-height: 44px;
            }
            .timer {
                font-size: 1rem;
                padding: 0.6rem;
            }
            .detection-area {
                max-height: 28vh;
            }
            .exam-questions {
                height: calc(100vh - 28vh - 44px);
                height: calc(-webkit-fill-available - 28vh);
            }
        }
        
        /* Fix iOS Safari viewport height issues */
        @supports (-webkit-touch-callout: none) {
            .exam-container {
                min-height: -webkit-fill-available;
                height: -webkit-fill-available;
            }
            html, body {
                height: -webkit-fill-available;
            }
        }
        
        /* Android Chrome viewport fixes */
        @media screen and (-webkit-min-device-pixel-ratio: 1) {
            .exam-container {
                min-height: 100vh;
                min-height: 100dvh; /* Dynamic viewport height */
            }
        }

        @media (max-width:520px){
            .caption-line{font-size:0.92rem}
            .permission-content {
                padding: 1.5rem;
                margin: 1rem;
            }
            .permission-item {
                flex-direction: column;
                text-align: center;
                gap: 0.5rem;
            }
            .permission-buttons {
                flex-direction: column;
            }
            .permission-buttons .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- IMMEDIATE RIGHT-CLICK PREVENTION - Runs before any other scripts -->
    <script>
        // Prevent right-click context menu IMMEDIATELY on page load
        // This must run before any other scripts to prevent context menu from appearing
        (function() {
            'use strict';
            
            // Violation queue to store violations before logAlert is available
            window.violationQueue = window.violationQueue || [];
            
            // Function to log violations (will be called when logAlert becomes available)
            function queueViolation(type, message) {
                window.violationQueue.push({ type: type, message: message, timestamp: Date.now() });
                // Try to process queue immediately if logAlert is available
                processViolationQueue();
            }
            
            // Process queued violations once logAlert is available
            function processViolationQueue() {
                if (typeof logAlert === 'function' && window.violationQueue.length > 0) {
                    const queue = window.violationQueue.slice(); // Copy queue
                    window.violationQueue = []; // Clear queue
                    queue.forEach(function(violation) {
                        try {
                            logAlert(violation.type, violation.message);
                        } catch (e) {
                            console.warn('Failed to log violation:', e);
                            // Re-queue if logging failed
                            window.violationQueue.push(violation);
                        }
                    });
                }
            }
            
            // Expose processViolationQueue globally so it can be called when logAlert becomes available
            window.processViolationQueue = processViolationQueue;
            
            // Prevent context menu (right-click menu)
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                queueViolation('right_click', 'Right-click attempted (contextmenu)');
                return false;
            }, true);
            
            // Prevent right-click via mousedown
            document.addEventListener('mousedown', function(e) {
                if (e.button === 2) { // Right mouse button
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    queueViolation('right_click', 'Right-click attempted (mousedown)');
                    return false;
                }
            }, true);
            
            // Prevent right-click via mouseup
            document.addEventListener('mouseup', function(e) {
                if (e.button === 2) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    queueViolation('right_click', 'Right-click attempted (mouseup)');
                    return false;
                }
            }, true);
            
            // Prevent keyboard shortcuts for developer tools
            document.addEventListener('keydown', function(e) {
                let violationType = null;
                let violationMessage = null;
                
                // F12 (Developer Tools)
                if (e.key === 'F12') {
                    e.preventDefault();
                    e.stopPropagation();
                    violationType = 'keyboard_shortcut';
                    violationMessage = 'F12 pressed (Developer Tools)';
                }
                // Ctrl+Shift+I (Developer Tools)
                else if (e.ctrlKey && e.shiftKey && e.key === 'I') {
                    e.preventDefault();
                    e.stopPropagation();
                    violationType = 'keyboard_shortcut';
                    violationMessage = 'Ctrl+Shift+I pressed (Developer Tools)';
                }
                // Ctrl+Shift+J (Console)
                else if (e.ctrlKey && e.shiftKey && e.key === 'J') {
                    e.preventDefault();
                    e.stopPropagation();
                    violationType = 'keyboard_shortcut';
                    violationMessage = 'Ctrl+Shift+J pressed (Console)';
                }
                // Ctrl+Shift+C (Inspect Element)
                else if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                    e.preventDefault();
                    e.stopPropagation();
                    violationType = 'keyboard_shortcut';
                    violationMessage = 'Ctrl+Shift+C pressed (Inspect Element)';
                }
                // Ctrl+U (View Source)
                else if (e.ctrlKey && e.key === 'U') {
                    e.preventDefault();
                    e.stopPropagation();
                    violationType = 'keyboard_shortcut';
                    violationMessage = 'Ctrl+U pressed (View Source)';
                }
                // Ctrl+Shift+P (Command Palette)
                else if (e.ctrlKey && e.shiftKey && e.key === 'P') {
                    e.preventDefault();
                    e.stopPropagation();
                    violationType = 'keyboard_shortcut';
                    violationMessage = 'Ctrl+Shift+P pressed (Command Palette)';
                }
                
                if (violationType) {
                    queueViolation(violationType, violationMessage);
                    return false;
                }
            }, true);
            
            // Prevent text selection
            document.addEventListener('selectstart', function(e) {
                e.preventDefault();
                return false;
            }, true);
            
            // Prevent copy, paste, cut
            document.addEventListener('copy', function(e) {
                e.preventDefault();
                if (e.clipboardData) {
                    e.clipboardData.setData('text/plain', '');
                }
                queueViolation('keyboard_shortcut', 'Copy attempted');
                return false;
            }, true);
            
            document.addEventListener('paste', function(e) {
                e.preventDefault();
                if (e.clipboardData) {
                    e.clipboardData.setData('text/plain', '');
                }
                queueViolation('keyboard_shortcut', 'Paste attempted');
                return false;
            }, true);
            
            document.addEventListener('cut', function(e) {
                e.preventDefault();
                if (e.clipboardData) {
                    e.clipboardData.setData('text/plain', '');
                }
                queueViolation('keyboard_shortcut', 'Cut attempted');
                return false;
            }, true);
            
            // Prevent drag
            document.addEventListener('dragstart', function(e) {
                e.preventDefault();
                return false;
            }, true);
            
            console.log('Right-click prevention activated immediately');
        })();
    </script>
    <!-- Permission Request Modal -->
    <div id="permissionModal" class="permission-modal">
        <div class="permission-content">
            <div class="permission-header">
                <h3>Camera & Microphone Access Required</h3>
                <p>To take this exam, we need access to your camera and microphone for proctoring purposes.</p>
            </div>
            <div class="permission-details">
                <div class="permission-item">
                    <div class="permission-icon">üìπ</div>
                    <div>
                        <strong>Camera Access</strong>
                        <p>Used to monitor your exam environment and ensure you remain visible.</p>
                    </div>
                </div>
                <div class="permission-item">
                    <div class="permission-icon">üé§</div>
                    <div>
                        <strong>Microphone Access</strong>
                        <p>Used to detect unusual sounds and ensure a quiet testing environment.</p>
                    </div>
                </div>
            </div>
            <div class="permission-buttons">
                <button class="btn btn-secondary" onclick="denyPermissions()">Deny Access</button>
                <button class="btn btn-primary" onclick="requestPermissions()">Allow Access</button>
            </div>
        </div>
    </div>

    <!-- Pause Modal -->
    <div id="pauseModal" class="permission-modal" style="display: none;">
        <div class="permission-content">
            <div class="permission-header">
                <h3>Exam Paused</h3>
                <p id="pauseMessage">Violation detected. Click Continue to resume the exam.</p>
            </div>
            <div class="permission-buttons">
                <button class="btn btn-primary" onclick="resumeExam()">Continue</button>
            </div>
        </div>
    </div>

    <div class="exam-container" id="examContainer" style="display: none;">
        <!-- Left side: Proctoring -->
    <div class="detection-area" id="detectionArea">


        <div class="proctor-header">
            <button class="back-btn" onclick="window.history.back()" title="Go Back">
                <i class="bx bx-arrow-back"></i>
            </button>
            <div class="logo">
                    <img src="static/images/logo.jpg.jpg" alt="Logo" style="width:32px;height:32px;border-radius:8px;object-fit:cover">
            </div>
            <div class="title">Proctoring Active</div>
        </div>





        <div class="viewer">
            <!-- Alerts area -->
            <div id="alerts" aria-live="polite">
                <div id="alert-noface" class="alert danger">No face detected!</div>
                <div id="alert-multiplefaces" class="alert warn">Multiple faces detected!</div>
                <div id="alert-phone" class="alert warn">Phone detected!</div>
                <div id="alert-loudsound" class="alert danger">Loud sound detected!</div>

                <div id="alert-mvoices" class="alert danger">Multiple voices detected!</div>
            </div>

            <div class="media">
                <video id="video" autoplay playsinline></video>
            </div>

            <div class="controls">
                <div id="label">Waiting for frames...</div>
                <div class="prob">
                    <div class="bar"><i id="barFill"></i></div>
                    <div id="probText" class="small">‚Äî</div>
                </div>
            </div>

            <img id="processed" src="" alt="Processed preview" />

            <div class="mic-ui" aria-live="polite">
                <div class="mic-row">
                    <div class="mic-label">Microphone</div>
                    <div class="mic-meter"><div id="micFill" class="mic-fill"></div></div>
                    <div id="micStatus" class="mic-status">Initializing‚Ä¶</div>
                </div>
            </div>

            <!-- Captions area -->
                <div id="captions" class="captions" aria-live="polite" style="display:block; margin-top:10px; padding:8px; background:rgba(0,0,0,0.5); border-radius:8px; font-size:0.9rem; color:#e6eef8; min-height:30px;">Listening...</div>

                <!-- Alert Distribution Panel for Students -->
                <div id="studentAlertDistribution" class="student-alert-distribution" style="margin-top:15px; padding:12px; background:rgba(255,255,255,0.05); border-radius:10px; border:1px solid rgba(255,255,255,0.1);">
                    <div style="font-weight:600; font-size:0.95rem; margin-bottom:10px; color:#e6eef8; display:flex; align-items:center; gap:8px;">
                        <span>‚ö†Ô∏è</span>
                        <span>Your Violations</span>
                    </div>
                    <div class="alert-dist-list" style="display:flex; flex-direction:column; gap:6px; font-size:0.85rem;">
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffd59a;">Multiple Faces</span>
                            <span class="badge" id="student-alert-twofaces" style="background:rgba(255,165,0,0.2); color:#ffd59a; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                        </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffb3b3;">Loud Sound</span>
                            <span class="badge" id="student-alert-loud-sound" style="background:rgba(255,80,80,0.2); color:#ffb3b3; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                        </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffd59a;">Phone Detected</span>
                            <span class="badge" id="student-alert-phone" style="background:rgba(255,165,0,0.2); color:#ffd59a; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                        </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffb3b3;">Fullscreen Exit</span>
                            <span class="badge" id="student-alert-fullscreen-exit" style="background:rgba(255,80,80,0.2); color:#ffb3b3; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                        </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffd59a;">Keyboard Shortcut</span>
                            <span class="badge" id="student-alert-keyboard-shortcut" style="background:rgba(255,165,0,0.2); color:#ffd59a; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                        </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffd59a;">Right Click</span>
                            <span class="badge" id="student-alert-right-click" style="background:rgba(255,165,0,0.2); color:#ffd59a; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                        </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffd59a;">Tab Switch</span>
                            <span class="badge" id="student-alert-tab-switch" style="background:rgba(255,165,0,0.2); color:#ffd59a; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                        </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffd59a;">Speech Detected</span>
                            <span class="badge" id="student-alert-captions" style="background:rgba(255,165,0,0.2); color:#ffd59a; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                        </div>
                        <div class="alert-dist-item" style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <span style="color:#ffb3b3;">Face Absent</span>
                            <span class="badge" id="student-alert-face-absent" style="background:rgba(255,80,80,0.2); color:#ffb3b3; padding:2px 8px; border-radius:4px; font-weight:600; min-width:30px; text-align:center;">0</span>
                        </div>
                    </div>
                </div>
                </div>
</div>

        <!-- Right side: Exam Questions -->
        <div class="exam-questions">
            <div class="timer" id="examTimer">Time Left: 60:00</div>
            <div class="timer" id="examStopwatch" style="background: rgba(110,231,183,0.1); border-color: var(--accent); margin-top: 0.5rem;">Time Elapsed: 00:00</div>

            <h2 id="examTitle">Quiz 1</h2>
            <p class="text-white mb-4" id="examSubject">Subject: CC105</p>

            <div id="questionsContainer">
                <!-- Questions will be loaded here -->
                </div>

            <button class="btn btn-primary mt-4" onclick="submitExam()">Submit Exam</button>
    </div>
</div>

    <!-- Reduced canvas size for Render free tier memory optimization (640x480) -->
    <canvas id="canvas" width="640" height="480" style="display:none;"></canvas>

    <script>

</script>
    <!-- Keep existing scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <!-- Add new script for exam functionality -->
    <script>
        // Set userId from template
        const templateUserId = '{{ user_id or "" }}';
        if (templateUserId) {
            sessionStorage.setItem('userId', templateUserId);
        }

        // Function to show exam alerts to students
        function showExamAlert(message) {
            // Create or get alert element
            let alertBox = document.getElementById('examInlineAlert');
            if (!alertBox) {
                alertBox = document.createElement('div');
                alertBox.id = 'examInlineAlert';
                alertBox.style.cssText = 'position:fixed; top:20px; left:50%; transform:translateX(-50%); background:rgba(255,193,7,0.95); color:#000; padding:12px 20px; border-radius:8px; font-weight:600; z-index:10000; box-shadow:0 4px 12px rgba(0,0,0,0.3); max-width:500px; text-align:center;';
                document.body.appendChild(alertBox);
            }

        alertBox.textContent = message;
            alertBox.style.display = 'block';

            // Auto-hide after 3 seconds
        setTimeout(() => {
                if (alertBox) {
                    alertBox.style.display = 'none';
                }
        }, 3000);
    }



        // Exam state
        let examState = {
            examId: null,
            userId: null,
            answers: [],
            submitted: false,
            terminated: false, // Flag to indicate if exam was terminated due to violation
            questions: [], // Store exam questions for speech detection
            allAnswers: [], // Store all possible answers for speech detection
            finalElapsedTime: null // Store final elapsed time when exam ends
        };

        // Global timer variable
        let countdownTimer = null;

        // Update alertsSession structure to include captions and clip recording
        let alertsSession = {
            sessionId: null,
            userId: null,
            examId: null,
            flags: {
                face_absent: [],
                twofaces: [],
                loud_sound: [],
                phone: [],
                fullscreen_exit: [],
                keyboard_shortcut: [],
                right_click: [],
                tab_switch: [],
                captions: []
            },
            clipRecorded: false, // Track if a cheating clip has been recorded
            clipRecorder: null,
            clipChunks: []
        };

        // Alert counting for exam termination
        let totalAlertCount = 0;
        let lastAlertTime = 0;
        const ALERT_COOLDOWN = 5000; // 5 seconds between counting alerts
        let examTerminated = false; // Flag to prevent multiple terminations
        let currentPausedType = null; // Track currently paused violation type
        let isExamPaused = false; // Global flag to track if exam is paused (stops all detection)

        // Initialize exam with session data
        async function initExam() {
            // Get exam ID from URL
            const pathParts = window.location.pathname.split('/');
            examState.examId = pathParts[pathParts.length - 1];
            examState.userId = sessionStorage.getItem('userId');

            // Check if exam was already taken
            try {
                const userResponse = await fetch(`/select?collection=users&id=${examState.userId}`);
                const userData = await userResponse.json();
                
                if (userData.exams_taken && userData.exams_taken.includes(examState.examId)) {
                    alert('You have already taken this exam');
                    window.location.href = '/student_dashboard';
                    return;
                }

                // Load exam data
                const examResponse = await fetch(`/select?collection=exams&id=${examState.examId}`);
                const examData = await examResponse.json();

                document.getElementById('examTitle').textContent = examData.title;
                document.getElementById('examSubject').textContent = `Subject: ${examData.subject}`;
                
                // Store exam questions and answers for speech detection
                examState.questions = examData.questions.map(q => q.text.toLowerCase());
                examState.allAnswers = [];
                examData.questions.forEach(q => {
                    examState.allAnswers.push(q.correctAnswer.toLowerCase());
                    q.wrongAnswers.forEach(ans => {
                        examState.allAnswers.push(ans.toLowerCase());
                    });
                });
                
                const container = document.getElementById('questionsContainer');
                examData.questions.forEach((q, idx) => {
                    const answers = [q.correctAnswer, ...q.wrongAnswers].sort(() => Math.random() - 0.5);
                    
                    const questionHtml = `
                        <div class="question-card">
                            <h5>Question ${idx + 1}</h5>
                            <p>${q.text}</p>
                            <div class="answers">
                                ${answers.map((answer, i) => `
                                    <div class="answer-option" onclick="selectAnswer(${idx}, ${i}, this)">
                                        ${answer}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    container.innerHTML += questionHtml;
                });

                startTimer(examData.duration * 60);

            } catch (err) {
                console.error('Error initializing exam:', err);
                alert('Error loading exam');
                window.location.href = '/student_dashboard';
            }
        }

        // Timer functionality
        let examElapsedTime = 0; // Global variable to track elapsed time (in seconds)
        let examStartTime = null; // Timestamp when exam started (for precise calculation)
        function startTimer(duration) {
            let timer = duration;
            examElapsedTime = 0;
            examStartTime = Date.now(); // Record exact start time
            const timerEl = document.getElementById('examTimer');
            const stopwatchEl = document.getElementById('examStopwatch');

            countdownTimer = setInterval(() => {
                const minutes = Math.floor(timer / 60);
                const seconds = timer % 60;

                timerEl.textContent = `Time Left: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                // Calculate exact elapsed time from start timestamp
                const elapsedMs = Date.now() - examStartTime;
                examElapsedTime = Math.floor(elapsedMs / 1000); // Convert to seconds

                // Update stopwatch with proper HH:MM:SS format
                const elapsedHours = Math.floor(examElapsedTime / 3600);
                const elapsedMinutes = Math.floor((examElapsedTime % 3600) / 60);
                const elapsedSeconds = examElapsedTime % 60;
                stopwatchEl.textContent = `Time Elapsed: ${elapsedHours.toString().padStart(2, '0')}:${elapsedMinutes.toString().padStart(2, '0')}:${elapsedSeconds.toString().padStart(2, '0')}`;

                if (--timer < 0) {
                    // Calculate final elapsed time when timer expires naturally
                    const finalElapsedMs = Date.now() - examStartTime;
                    examState.finalElapsedTime = Math.floor(finalElapsedMs / 1000);
                    clearInterval(countdownTimer);
                    countdownTimer = null;
                    submitExam();
                }
            }, 1000);
        }

        // Handle answer selection
        function selectAnswer(questionIdx, answerIdx, element) {
            examState.answers[questionIdx] = answerIdx;
            const questionCard = element.closest('.question-card');
            questionCard.querySelectorAll('.answer-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            element.classList.add('selected');
            
            // Touch feedback for mobile
            if (window.TouchEvent || 'ontouchstart' in window) {
                element.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    element.style.transform = '';
                }, 150);
            }
        }
        
        // Add touch event support for better mobile interaction
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            document.addEventListener('DOMContentLoaded', function() {
                // Improve touch feedback for answer options
                document.addEventListener('touchstart', function(e) {
                    const answerOption = e.target.closest('.answer-option');
                    if (answerOption) {
                        answerOption.style.opacity = '0.7';
                    }
                }, { passive: true });
                
                document.addEventListener('touchend', function(e) {
                    const answerOption = e.target.closest('.answer-option');
                    if (answerOption) {
                        answerOption.style.opacity = '';
                    }
                }, { passive: true });
            });
        }

        // Submit exam
        async function submitExam() {
            if (examState.submitted) {
                alert('Exam already submitted');
                return;
            }

            // Capture elapsed time immediately before clearing timer
            // Use stored finalElapsedTime if available (from termination), otherwise calculate from start time
            let finalElapsedTime;
            if (examState.finalElapsedTime !== null) {
                finalElapsedTime = examState.finalElapsedTime;
            } else if (examStartTime !== null) {
                // Calculate exact elapsed time from start timestamp
                const elapsedMs = Date.now() - examStartTime;
                finalElapsedTime = Math.floor(elapsedMs / 1000);
            } else {
                // Fallback to counter if start time not available
                finalElapsedTime = examElapsedTime;
            }

            // Clear the timer immediately when submitting
            if (countdownTimer) {
                clearInterval(countdownTimer);
                countdownTimer = null;
            }

            const answers = [];
            document.querySelectorAll('.question-card').forEach(card => {
                const selected = card.querySelector('.answer-option.selected');
                answers.push(selected ? selected.textContent.trim() : null);
            });

            examState.answers = answers;
            examState.submitted = true;

            try {
                // stop & finalize recording if running (upload handled in onstop)
                if (window.mediaRecorder && window.mediaRecorder.state !== 'inactive') {
                    try { window.mediaRecorder.stop(); } catch(e) { console.warn('stop mediaRecorder failed', e); }
                }

                // wait for video upload to finish (if any)
                if (alertsSession.videoUploadPromise) {
                    try { await alertsSession.videoUploadPromise; } catch(e) { console.warn('video upload failed', e); }
                }

                // Update user's exam history - mark as taken even if terminated to block retakes
                const userResponse = await fetch(`/select?collection=users&id=${examState.userId}`);
                const userData = await userResponse.json();
                const currentExams = userData.exams_taken || [];
                if (!currentExams.includes(examState.examId)) {
                    currentExams.push(examState.examId);
                }

                const updateResponse = await fetch(`/edit/${examState.userId}?collection=users`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        exams_taken: currentExams
                    })
                });

                if (!updateResponse.ok) {
                    console.error('Failed to update user exams_taken');
                }

                // Calculate hours, minutes, and seconds from elapsed time
                const hours = Math.floor(finalElapsedTime / 3600);
                const minutes = Math.floor((finalElapsedTime % 3600) / 60);
                const seconds = finalElapsedTime % 60;

                // Save exam results using backend endpoint with time taken in seconds
                await fetch('/add?collection=exam_results', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: examState.userId,
                        exam_id: examState.examId,
                        answers: examState.answers,
                        timestamp: new Date().toISOString(),
                        terminated: !!examState.terminated,
                        forced_score: examState.forceZeroScore ? 0 : undefined,
                        time_taken: finalElapsedTime, // Time taken in seconds
                        time_taken_formatted: `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}` // Formatted as HH:MM:SS
                    })
                });

                // Close proctoring session
                if (alertsSession.sessionId) {
                    await fetch(`/edit/${alertsSession.sessionId}?collection=proctoring_sessions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            flags: alertsSession.flags,
                            end_time: new Date().toISOString(),
                            status: 'completed'
                        })
                    });
                }

                // Log final flags from backend detection
                if (alertsSession.sessionId) {
                    try {
                        const sessionData = await fetch(`/select?collection=proctoring_sessions&id=${alertsSession.sessionId}`);
                        const session = await sessionData.json();
                        if (session.flags) {
                            for (const [flagType, flagList] of Object.entries(session.flags)) {
                                flagList.forEach(flag => {
                                    alertsSession.flags[flagType] = alertsSession.flags[flagType] || [];
                                    alertsSession.flags[flagType].push(flag);
                                });
                            }
                        }
                    } catch (e) {
                        console.warn('Failed to fetch final flags:', e);
                    }
                }

                alert('Exam submitted successfully! You will be redirected to your dashboard.');
                // Clear any cached data and redirect
                sessionStorage.removeItem('examData');
                window.location.href = '/student_dashboard';

            } catch (err) {
                console.error('Error submitting exam:', err);
                alert('Error submitting exam. Please try again.');
            }
        }

        // Modified initAlertsSession function
        async function initAlertsSession() {
            // Process any queued violations from immediate prevention script once session is initialized
            setTimeout(() => {
                if (typeof window.processViolationQueue === 'function') {
                    window.processViolationQueue();
                }
            }, 100);
            // Verify authentication before creating/reusing session
            if (!examState.userId || !sessionStorage.getItem('userId')) {
                console.error('Cannot create proctoring session: User not authenticated');
                return;
            }

            try {
                // Ask backend to get an existing active/paused session
                // for this student+exam, or create a new one if none exists.
                const response = await fetch('/get_or_create_session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        student_id: examState.userId,
                        exam_id: examState.examId
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to initialize proctoring session');
                }

                const data = await response.json();
                alertsSession.sessionId = data.session_id;
                alertsSession.userId = examState.userId;
                alertsSession.examId = examState.examId;

                // If session already exists and has flags in Firestore, merge them into alertsSession.flags
                if (data.session && data.session.flags && alertsSession.flags) {
                    const serverFlags = data.session.flags || {};
                    for (const [flagType, flagList] of Object.entries(serverFlags)) {
                        if (!Array.isArray(flagList)) continue;
                        alertsSession.flags[flagType] = alertsSession.flags[flagType] || [];
                        // Avoid duplicating entries on repeated init calls by only adding new ones
                        const existing = alertsSession.flags[flagType];
                        flagList.forEach(f => {
                            // Simple duplicate check by timestamp+message if present
                            const keyTs = f.timestamp || f.time || '';
                            const keyMsg = f.message || f.text || '';
                            const already = existing.some(e =>
                                (e.timestamp || e.time || '') === keyTs &&
                                (e.message || e.text || '') === keyMsg
                            );
                            if (!already) {
                                existing.push(f);
                            }
                        });
                    }
                }
            } catch (err) {
                console.error('Error initializing proctoring session:', err);
            }
        }

        // Function to start recording a 5-second clip when cheating is detected
        async function startCheatingClip() {
            if (alertsSession.clipRecorded || !window.mediaRecorder) return;

            try {
                alertsSession.clipChunks = [];
                alertsSession.clipRecorder = new MediaRecorder(window.mediaRecorder.stream, {
                    mimeType: window.mediaRecorder.mimeType,
                    bitsPerSecond: 2000000
                });

                alertsSession.clipRecorder.ondataavailable = (ev) => {
                    if (ev.data && ev.data.size > 0) {
                        alertsSession.clipChunks.push(ev.data);
                    }
                };

                alertsSession.clipRecorder.onstop = async () => {
                    const clipBlob = new Blob(alertsSession.clipChunks, { type: alertsSession.clipRecorder.mimeType });
                    alertsSession.clipChunks = [];

                    const fd = new FormData();
                    fd.append('video', clipBlob, `cheating_clip_${alertsSession.sessionId}_${Date.now()}.webm`);

                    try {
                        const response = await fetch(`/upload_video?session_id=${encodeURIComponent(alertsSession.sessionId)}&type=clip`, {
                            method: 'POST',
                            body: fd
                        });
                        if (response.ok) {
                            alertsSession.clipRecorded = true;
                            console.log('Cheating clip uploaded successfully');
                        }
                    } catch (e) {
                        console.error('Failed to upload cheating clip:', e);
                    }
                };

                alertsSession.clipRecorder.start();
                setTimeout(() => {
                    if (alertsSession.clipRecorder && alertsSession.clipRecorder.state === 'recording') {
                        alertsSession.clipRecorder.stop();
                    }
                }, 5000); // Record for 5 seconds

            } catch (e) {
                console.warn('Failed to start cheating clip recording:', e);
            }
        }

        // Security features: tab switch detection, fullscreen locking, copy-paste prevention
        async function initSecurityFeatures() {
            // Enter fullscreen mode - try harder on mobile
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            try {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    await elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) { // Safari
                    await elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { // IE11
                    await elem.msRequestFullscreen();
                } else if (isMobile && elem.webkitEnterFullscreen) { // iOS specific
                    await elem.webkitEnterFullscreen();
                }
                // Double-check on mobile after a short delay to ensure fullscreen sticks
                if (isMobile) {
                    setTimeout(() => {
                        if (!document.fullscreenElement &&
                            !(document.webkitFullscreenElement) &&
                            elem.requestFullscreen) {
                            elem.requestFullscreen().catch(() => {});
                        }
                    }, 500);
                }
            } catch (err) {
                console.warn('Fullscreen request failed:', err);
                if (isMobile) {
                    // On mobile, don't block the exam if fullscreen fails initially
                    alert('Fullscreen mode is recommended for this exam. Please rotate to landscape and allow fullscreen when prompted.');
                } else {
                    alert('Fullscreen mode is required for this exam. Please allow fullscreen and refresh the page.');
                    return;
                }
            }

            // Prevent exiting fullscreen
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);

            // Tab switch detection (with 3s grace handled in visibilitychange)
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            // Window blur/focus detection (catches Alt+Tab, clicking outside window, etc.) with 3s grace
            let windowBlurTime = null;
            window.addEventListener('blur', () => {
                // Stop detection when exam is paused
                if (isExamPaused) return;
                windowBlurTime = Date.now();
            });
            
            window.addEventListener('focus', () => {
                // Stop detection when exam is paused
                if (isExamPaused) return;
                
                if (windowBlurTime) {
                    const awayMs = Date.now() - windowBlurTime;
                    if (awayMs >= 3000) {
                        registerTabSwitch(awayMs);
                    }
                }
                windowBlurTime = null;
            });

            // Window resize detection (flag resizing attempts)
            let lastSize = { w: window.innerWidth, h: window.innerHeight };
            let resizeTimer = null;
            window.addEventListener('resize', () => {
                if (resizeTimer) clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    const deltaW = Math.abs(window.innerWidth - lastSize.w);
                    const deltaH = Math.abs(window.innerHeight - lastSize.h);
                    if (deltaW > 50 || deltaH > 50) {
                        logAlert('resize_window', `Window resized (${deltaW}px x ${deltaH}px change)`);
                        showExamAlert('‚ö†Ô∏è Resizing the window is not allowed during the exam.');
                    }
                    lastSize = { w: window.innerWidth, h: window.innerHeight };
                }, 400);
            });

            // Copy-paste prevention
            disableCopyPaste();

            console.log('Security features initialized');
        }

        // Fullscreen enforcement modal
        let fullscreenModal = null;

        function createFullscreenModal() {
            if (fullscreenModal) return fullscreenModal;

            fullscreenModal = document.createElement('div');
            fullscreenModal.id = 'fullscreenModal';
            fullscreenModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0,0,0,0.95);
                display: none;
                z-index: 10000;
                align-items: center;
                justify-content: center;
                flex-direction: column;
                font-family: Inter, sans-serif;
                color: white;
            `;

            fullscreenModal.innerHTML = `
                <div style="text-align: center; padding: 2rem;">
                    <div style="font-size: 3rem; margin-bottom: 1rem;">‚ö†Ô∏è</div>
                    <h2 style="margin-bottom: 1rem; color: #ff6b6b;">FULLSCREEN REQUIRED</h2>
                    <p style="margin-bottom: 2rem; font-size: 1.1rem; line-height: 1.5;">
                        This exam must be taken in fullscreen mode.<br>
                        Click the button below to continue.
                    </p>
                    <button id="fullscreenBtn" style="
                        background: #6ee7b7;
                        color: #032;
                        border: none;
                        padding: 1rem 2rem;
                        font-size: 1.2rem;
                        font-weight: 600;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: background 0.2s;
                    ">Enter Fullscreen Mode</button>
                </div>
            `;

            document.body.appendChild(fullscreenModal);

            // Add click handler for the fullscreen button
            document.getElementById('fullscreenBtn').onclick = async () => {
                try {
                    const elem = document.documentElement;
                    if (elem.requestFullscreen) {
                        await elem.requestFullscreen();
                    } else if (elem.webkitRequestFullscreen) { // Safari
                        await elem.webkitRequestFullscreen();
                    } else if (elem.msRequestFullscreen) { // IE11
                        await elem.msRequestFullscreen();
                    } else if (elem.webkitEnterFullscreen) { // iOS Safari
                        await elem.webkitEnterFullscreen();
                    }
                } catch (e) {
                    console.warn('Failed to enter fullscreen:', e);
                    alert('Unable to enter fullscreen mode. Please use F11 or browser controls.');
                }
            };

            return fullscreenModal;
        }

        function handleFullscreenChange() {
            // Stop detection when exam is paused
            if (isExamPaused) return;
            
            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement ||
                               document.mozFullScreenElement || document.msFullscreenElement;

            if (!isFullscreen) {
                // User exited fullscreen - flag as cheating and show modal
                logAlert('fullscreen_exit', 'User exited fullscreen mode');

                const modal = createFullscreenModal();
                modal.style.display = 'flex';

                // Disable exam interaction while modal is shown
                const examContainer = document.getElementById('examContainer');
                if (examContainer) {
                    examContainer.style.pointerEvents = 'none';
                    examContainer.style.opacity = '0.3';
                }

                // Keep checking if user re-enters fullscreen
                const checkFullscreen = () => {
                    const nowFullscreen = document.fullscreenElement || document.webkitFullscreenElement ||
                                        document.mozFullScreenElement || document.msFullscreenElement;
                    if (nowFullscreen) {
                        // User successfully entered fullscreen - hide modal and restore exam
                        modal.style.display = 'none';
                        if (examContainer) {
                            examContainer.style.pointerEvents = 'auto';
                            examContainer.style.opacity = '1';
                        }
                    } else {
                        // Still not in fullscreen - keep checking
                        setTimeout(checkFullscreen, 100);
                    }
                };
                checkFullscreen();
            }
        }

        let tabSwitchCount = 0;
        let lastTabSwitchTime = 0;
        let hiddenStartTime = null;
        let isMobileAppExit = false;
        let mobileExitGracePeriod = false;

        function handleVisibilityChange() {
            // Stop detection when exam is paused
            if (isExamPaused) return;

            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            if (document.hidden) {
                hiddenStartTime = Date.now();
                isMobileAppExit = false;

                // On mobile, check if this might be an app exit (home button, app switch)
                if (isMobile) {
                    // Set a flag to indicate potential mobile app exit
                    // We'll check this when visibility returns
                    setTimeout(() => {
                        if (document.hidden && !isMobileAppExit) {
                            isMobileAppExit = true;
                            logAlert('tab_switch', 'Mobile app potentially exited (home button or app switch detected)');
                            showExamAlert('‚ö†Ô∏è App exit detected. Please return to the exam immediately.');
                        }
                    }, 1000); // Check after 1 second of being hidden
                }
            } else {
                // User came back; measure how long they were away
                if (hiddenStartTime) {
                    const awayMs = Date.now() - hiddenStartTime;
                    hiddenStartTime = null;

                    // On mobile, if we detected an app exit, always flag it
                    if (isMobile && isMobileAppExit) {
                        registerTabSwitch(awayMs, true); // Force flag as mobile app exit
                        isMobileAppExit = false;
                    } else if (awayMs >= 3000) { // only flag if away > 3s for regular tab switches
                        registerTabSwitch(awayMs, false);
                    }

                    // Give mobile devices a grace period after returning to prevent false face detection
                    if (isMobile) {
                        mobileExitGracePeriod = true;
                        setTimeout(() => {
                            mobileExitGracePeriod = false;
                        }, 3000); // 3 second grace period for camera to stabilize
                    }
                }
                isMobileAppExit = false;
            }
        }

        function registerTabSwitch(awayMs, forceFlag = false) {
            // Stop detection when exam is paused
            if (isExamPaused) return;

            const now = Date.now();
            // additional debounce to avoid double count between visibility/blur handlers
            if (now - lastTabSwitchTime > 500) {
                tabSwitchCount++;
                lastTabSwitchTime = now;

                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const exitType = forceFlag ? 'mobile app exit' : (isMobile ? 'mobile tab switch' : 'tab switch');

                logAlert('tab_switch', `User ${exitType} for ${Math.round(awayMs/1000)}s (count: ${tabSwitchCount})`);
                if (tabSwitchCount >= 3) {
                    showExamAlert(`‚ö†Ô∏è Warning: You have left the exam window ${tabSwitchCount} times. Continued exits may terminate the exam.`);
                }
            }
        }

        // Global right-click prevention - applied immediately on page load
        // This prevents right-click from the very start, before exam begins
        function preventRightClickGlobal(e) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            // Show alert if exam is active, otherwise just prevent silently
            if (typeof logAlert === 'function' && typeof isExamPaused !== 'undefined' && !isExamPaused) {
                logAlert('right_click', 'Right-click attempted');
                if (typeof showExamAlert === 'function') {
                    showExamAlert('‚ö†Ô∏è Right-click is disabled during the exam.');
                }
            } else {
                // Before exam starts, just prevent silently
                console.log('Right-click disabled');
            }
            return false;
        }

        function disableCopyPaste() {
            // Disable right-click context menu - CRITICAL for preventing inspection and fullscreen exit
            // Note: Global prevention is already applied, this adds exam-specific logging
            document.addEventListener('contextmenu', (e) => {
                // Stop detection when exam is paused
                if (typeof isExamPaused !== 'undefined' && isExamPaused) return;
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                if (typeof logAlert === 'function') {
                    logAlert('right_click', 'Right-click attempted');
                }
                if (typeof showExamAlert === 'function') {
                    showExamAlert('‚ö†Ô∏è Right-click is disabled during the exam.');
                }
                return false;
            }, true);

            // Also prevent right-click on specific elements (mousedown)
            document.addEventListener('mousedown', (e) => {
                // Stop detection when exam is paused
                if (isExamPaused) return;
                
                if (e.button === 2) { // Right mouse button
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    logAlert('right_click', 'Right-click attempted (mousedown)');
                    showExamAlert('‚ö†Ô∏è Right-click is disabled during the exam.');
                    return false;
                }
            }, true);

            // Prevent right-click via mouseup as well
            document.addEventListener('mouseup', (e) => {
                if (isExamPaused) return;
                if (e.button === 2) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    return false;
                }
            }, true);

            // Prevent keyboard shortcuts that could open dev tools or exit fullscreen
            document.addEventListener('keydown', (e) => {
                if (isExamPaused) return;
                
                // Prevent F12 (Developer Tools)
                if (e.key === 'F12') {
                    e.preventDefault();
                    e.stopPropagation();
                    logAlert('keyboard_shortcut', 'F12 pressed (Developer Tools)');
                    showExamAlert('‚ö†Ô∏è Developer tools are disabled during the exam.');
                    return false;
                }
                
                // Prevent Ctrl+Shift+I (Developer Tools)
                if (e.ctrlKey && e.shiftKey && e.key === 'I') {
                    e.preventDefault();
                    e.stopPropagation();
                    logAlert('keyboard_shortcut', 'Ctrl+Shift+I pressed (Developer Tools)');
                    showExamAlert('‚ö†Ô∏è Developer tools are disabled during the exam.');
                    return false;
                }
                
                // Prevent Ctrl+Shift+J (Console)
                if (e.ctrlKey && e.shiftKey && e.key === 'J') {
                    e.preventDefault();
                    e.stopPropagation();
                    logAlert('keyboard_shortcut', 'Ctrl+Shift+J pressed (Console)');
                    showExamAlert('‚ö†Ô∏è Developer tools are disabled during the exam.');
                    return false;
                }
                
                // Prevent Ctrl+Shift+C (Inspect Element)
                if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                    e.preventDefault();
                    e.stopPropagation();
                    logAlert('keyboard_shortcut', 'Ctrl+Shift+C pressed (Inspect Element)');
                    showExamAlert('‚ö†Ô∏è Developer tools are disabled during the exam.');
                    return false;
                }
                
                // Prevent Ctrl+U (View Source)
                if (e.ctrlKey && e.key === 'U') {
                    e.preventDefault();
                    e.stopPropagation();
                    logAlert('keyboard_shortcut', 'Ctrl+U pressed (View Source)');
                    showExamAlert('‚ö†Ô∏è View source is disabled during the exam.');
                    return false;
                }
                
                // Prevent Ctrl+Shift+P (Command Palette in some browsers)
                if (e.ctrlKey && e.shiftKey && e.key === 'P') {
                    e.preventDefault();
                    e.stopPropagation();
                    logAlert('keyboard_shortcut', 'Ctrl+Shift+P pressed');
                    return false;
                }
                
                // Try to prevent Escape key from exiting fullscreen
                // Note: Browsers may still allow Escape to exit fullscreen, but we'll try to prevent it
                if (e.key === 'Escape' || e.keyCode === 27) {
                    const isInFullscreen = !!(document.fullscreenElement || 
                                             document.webkitFullscreenElement || 
                                             document.mozFullScreenElement || 
                                             document.msFullscreenElement);
                    if (isInFullscreen) {
                        // Try to prevent fullscreen exit
                        e.preventDefault();
                        e.stopPropagation();
                        logAlert('fullscreen_exit', 'Escape key pressed (attempted fullscreen exit)');
                        showExamAlert('‚ö†Ô∏è Fullscreen mode must remain active during the exam.');
                        // Re-enter fullscreen after a short delay if it was exited
                        setTimeout(() => {
                            const stillInFullscreen = !!(document.fullscreenElement || 
                                                         document.webkitFullscreenElement || 
                                                         document.mozFullScreenElement || 
                                                         document.msFullscreenElement);
                            if (!stillInFullscreen) {
                                // Try to re-enter fullscreen
                                const elem = document.documentElement;
                                if (elem.requestFullscreen) {
                                    elem.requestFullscreen().catch(() => {});
                                } else if (elem.webkitRequestFullscreen) {
                                    elem.webkitRequestFullscreen();
                                } else if (elem.msRequestFullscreen) {
                                    elem.msRequestFullscreen();
                                }
                            }
                        }, 100);
                        return false;
                    }
                }
            }, true);

            // Disable text selection on entire page during exam
            document.addEventListener('selectstart', (e) => {
                if (isExamPaused) return;
                e.preventDefault();
                return false;
            }, true);

            // Disable drag
            document.addEventListener('dragstart', (e) => {
                if (isExamPaused) return;
                e.preventDefault();
                return false;
            }, true);

            // Prevent copy (Ctrl+C, Cmd+C)
            document.addEventListener('copy', (e) => {
                if (isExamPaused) return;
                e.preventDefault();
                e.clipboardData.setData('text/plain', '');
                logAlert('keyboard_shortcut', 'Copy attempted');
                return false;
            }, true);

            // Prevent paste (Ctrl+V, Cmd+V)
            document.addEventListener('paste', (e) => {
                if (isExamPaused) return;
                e.preventDefault();
                e.clipboardData.setData('text/plain', '');
                logAlert('keyboard_shortcut', 'Paste attempted');
                return false;
            }, true);

            // Prevent cut (Ctrl+X, Cmd+X)
            document.addEventListener('cut', (e) => {
                if (isExamPaused) return;
                e.preventDefault();
                e.clipboardData.setData('text/plain', '');
                logAlert('keyboard_shortcut', 'Cut attempted');
                return false;
            }, true);

            // Disable text selection on questions
            const questionContainer = document.getElementById('questionsContainer');
            if (questionContainer) {
                questionContainer.style.userSelect = 'none';
                questionContainer.style.webkitUserSelect = 'none';
                questionContainer.style.MozUserSelect = 'none';
                questionContainer.style.msUserSelect = 'none';
            }

            // Prevent keyboard shortcuts - comprehensive list
            document.addEventListener('keydown', (e) => {
                // Stop detection when exam is paused
                if (isExamPaused) return;
                
                let shortcutDetected = false;
                let shortcutName = '';

                // Ctrl/Cmd combinations
                if (e.ctrlKey || e.metaKey) {
                    const key = e.key.toLowerCase();
                    
                    // Copy, Paste, Cut, Select All
                    if (key === 'c' || key === 'v' || key === 'x' || key === 'a') {
                        shortcutDetected = true;
                        shortcutName = `Ctrl+${key.toUpperCase()}`;
                    }
                    // Save (Ctrl+S)
                    else if (key === 's') {
                        shortcutDetected = true;
                        shortcutName = 'Ctrl+S';
                    }
                    // Print (Ctrl+P)
                    else if (key === 'p') {
                        shortcutDetected = true;
                        shortcutName = 'Ctrl+P';
                    }
                    // Find (Ctrl+F)
                    else if (key === 'f') {
                        shortcutDetected = true;
                        shortcutName = 'Ctrl+F';
                    }
                    // View Source (Ctrl+U)
                    else if (key === 'u') {
                        shortcutDetected = true;
                        shortcutName = 'Ctrl+U';
                    }
                    // Reload (Ctrl+R, Ctrl+Shift+R)
                    else if (key === 'r') {
                        shortcutDetected = true;
                        shortcutName = e.shiftKey ? 'Ctrl+Shift+R' : 'Ctrl+R';
                    }
                    // New Tab (Ctrl+T)
                    else if (key === 't') {
                        shortcutDetected = true;
                        shortcutName = 'Ctrl+T';
                    }
                    // Close Tab (Ctrl+W)
                    else if (key === 'w') {
                        shortcutDetected = true;
                        shortcutName = 'Ctrl+W';
                    }
                    // Developer Tools (Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+Shift+C)
                    else if (e.shiftKey && (key === 'i' || key === 'j' || key === 'c')) {
                        shortcutDetected = true;
                        shortcutName = `Ctrl+Shift+${key.toUpperCase()}`;
                    }
                }
                
                // Function keys
                else if (e.key.startsWith('F')) {
                    // Block F12 (Developer Tools), F5 (Refresh), etc.
                    if (['F12', 'F5', 'F11'].includes(e.key)) {
                        shortcutDetected = true;
                        shortcutName = e.key;
                    }
                }
                
                // Screenshot / Print Screen attempts (best-effort)
                const keyLower = (e.key || '').toLowerCase();
                const isPrintScreen = keyLower === 'printscreen' || e.keyCode === 44;
                const isMacScreenshot = (e.metaKey && e.shiftKey && (keyLower === '3' || keyLower === '4' || keyLower === '5' || keyLower === '6'));
                const isCtrlShiftShot = (e.ctrlKey && e.shiftKey && (keyLower === 's' || keyLower === '4' || keyLower === '3'));

                if (isPrintScreen || isMacScreenshot || isCtrlShiftShot) {
                    shortcutDetected = true;
                    shortcutName = 'Screenshot / Print Screen';
                }
                
                // Alt+Tab detection (system shortcut, can't be prevented but can be detected)
                else if (e.altKey && e.key === 'Tab') {
                    shortcutDetected = true;
                    shortcutName = 'Alt+Tab';
                }

                // Escape key (prevent closing dialogs or exiting)
                else if (e.key === 'Escape') {
                    // Allow escape only for closing modals, but log it
                    if (!document.getElementById('permissionModal') ||
                        document.getElementById('permissionModal').style.display === 'none') {
                        shortcutDetected = true;
                        shortcutName = 'Escape';
                    }
                }

                if (shortcutDetected) {
                    e.preventDefault();
                    e.stopPropagation();
                    logAlert('keyboard_shortcut', `Keyboard shortcut attempted: ${shortcutName}`);
                    showExamAlert(`‚ö†Ô∏è Keyboard shortcut blocked: ${shortcutName}`);
                    return false;
                }
            }, true);

        // Prevent Ctrl+Shift+Delete (Clear browsing data) and add keyup guard for PrintScreen
            document.addEventListener('keyup', (e) => {
                // Stop detection when exam is paused
                if (isExamPaused) return;
            const keyLower = (e.key || '').toLowerCase();
            const isPrintScreen = keyLower === 'printscreen' || e.keyCode === 44;
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Delete') {
                    e.preventDefault();
                    logAlert('keyboard_shortcut', 'Keyboard shortcut attempted: Ctrl+Shift+Delete');
                    showExamAlert('‚ö†Ô∏è Keyboard shortcut blocked: Ctrl+Shift+Delete');
                    return false;
                }
            if (isPrintScreen) {
                e.preventDefault();
                e.stopPropagation();
                logAlert('keyboard_shortcut', 'Keyboard shortcut attempted: Print Screen');
                showExamAlert('‚ö†Ô∏è Screenshot shortcuts are disabled during the exam.');
                return false;
            }
            }, true);
        }

        // Check if speech contains exam questions or answers
        // Track last detection to prevent spam
        let lastExamContentDetection = 0;
        const EXAM_CONTENT_COOLDOWN = 3000; // 3 seconds between detections

        function checkForExamContent(transcript) {
            if (!examState.questions || examState.questions.length === 0) return;
            
            const transcriptLower = transcript.toLowerCase().trim();
            if (transcriptLower.length < 3) return; // Skip very short transcripts
            
            let examContentDetected = false;
            let detectedType = '';
            let detectedContent = '';
            
            // Check for exam questions - improved matching
            for (let i = 0; i < examState.questions.length; i++) {
                const question = examState.questions[i].toLowerCase();
                // Extract meaningful words (longer than 3 characters)
                const questionWords = question.split(' ').filter(w => w.length > 3);
                
                // Check if at least 3 key words from question appear in transcript
                const matchingWords = questionWords.filter(word => transcriptLower.includes(word));
                if (matchingWords.length >= 3) {
                    examContentDetected = true;
                    detectedType = 'question';
                    detectedContent = `Question ${i + 1}: "${question.substring(0, 60)}..."`;
                    break;
                }
            }
            
            // Check for exam answers - improved matching
            if (!examContentDetected) {
                for (let answer of examState.allAnswers) {
                    const answerLower = answer.toLowerCase().trim();
                    const answerWords = answerLower.split(' ');
                    
                    if (answerWords.length >= 3) {
                        // For longer answers, check if at least 2-3 key words match
                        const keyWords = answerWords.filter(w => w.length > 3).slice(0, 4);
                        if (keyWords.length >= 2) {
                            const matchingWords = keyWords.filter(word => transcriptLower.includes(word));
                            if (matchingWords.length >= 2) {
                                examContentDetected = true;
                                detectedType = 'answer';
                                detectedContent = `Answer: "${answer.substring(0, 50)}..."`;
                                break;
                            }
                        }
                    } else if (answerWords.length > 0) {
                        // For short answers, check if the full answer or significant part appears
                        if (transcriptLower.includes(answerLower) || 
                            (answerLower.length > 5 && transcriptLower.includes(answerLower.substring(0, Math.floor(answerLower.length * 0.7))))) {
                            examContentDetected = true;
                            detectedType = 'answer';
                            detectedContent = `Answer: "${answer}"`;
                            break;
                        }
                    }
                }
            }
            
            // If exam content detected, log as cheating alert (with cooldown)
            if (examContentDetected) {
                const now = Date.now();
                if (now - lastExamContentDetection > EXAM_CONTENT_COOLDOWN) {
                    lastExamContentDetection = now;
                    
                    const alertMessage = `üö® CHEATING DETECTED: Student is reading ${detectedType} from exam! (${detectedContent})`;
                    logAlert('captions', alertMessage);
                    showExamAlert(alertMessage);
                    
                    // Highlight captions in red to show it's a violation
                    const captionsElement = document.getElementById('captions');
                    if (captionsElement) {
                        captionsElement.style.background = 'rgba(255,80,80,0.4)';
                        captionsElement.style.border = '2px solid rgba(255,80,80,0.9)';
                        captionsElement.style.color = '#ffb3b3';
                        captionsElement.style.fontWeight = 'bold';
                        setTimeout(() => {
                            if (captionsElement) {
                                captionsElement.style.background = 'rgba(0,0,0,0.5)';
                                captionsElement.style.border = 'none';
                                captionsElement.style.color = '#e6eef8';
                                captionsElement.style.fontWeight = 'normal';
                            }
                        }, 5000);
                    }
                    
                    console.warn('EXAM CONTENT DETECTED IN SPEECH:', detectedType, detectedContent);
                }
            }
        }

        // Update student Alert Distribution panel
        function updateStudentAlertDistribution(type) {
            const idMap = {
                twofaces:          'student-alert-twofaces',
                loud_sound:        'student-alert-loud-sound',
                phone:             'student-alert-phone',
                fullscreen_exit:   'student-alert-fullscreen-exit',
                keyboard_shortcut: 'student-alert-keyboard-shortcut',
                right_click:       'student-alert-right-click',
                tab_switch:        'student-alert-tab-switch',
                captions:          'student-alert-captions',
                face_absent:       'student-alert-face-absent'
            };

            const elId = idMap[type];
            if (!elId) return;

            const badge = document.getElementById(elId);
            if (!badge) return;

            const current = parseInt(badge.textContent || '0', 10);
            badge.textContent = current + 1;

            // Add animation effect when count updates
            badge.style.transform = 'scale(1.2)';
            setTimeout(() => {
                badge.style.transform = 'scale(1)';
            }, 200);
        }

        // Helper to terminate exam with zero score
        function terminateExam(message) {
            if (examState.terminated) return;
            examState.terminated = true;
            examState.forceZeroScore = true;
            
            // Stop all detection immediately
            isExamPaused = true;

            // Capture elapsed time immediately before clearing timer and store it in examState
            // Calculate exact elapsed time from start timestamp
            if (examStartTime !== null) {
                const elapsedMs = Date.now() - examStartTime;
                examState.finalElapsedTime = Math.floor(elapsedMs / 1000);
            } else {
                examState.finalElapsedTime = examElapsedTime;
            }

            // Clear the timer immediately when terminating
            if (countdownTimer) {
                clearInterval(countdownTimer);
                countdownTimer = null;
            }

            // Stop further processing to avoid extra violations after exam ends
            try {
                running = false;
                if (sendInterval) clearInterval(sendInterval);
                sendInterval = null;
                stopSpeechRecognition && stopSpeechRecognition();
                if (audioCtx && audioCtx.state !== 'closed') {
                    audioCtx.close().catch(() => {});
                }
                if (micStream) {
                    micStream.getTracks().forEach(t => t.stop());
                }
                if (video && video.srcObject) {
                    video.srcObject.getTracks().forEach(t => t.stop());
                    video.srcObject = null;
                }
            } catch (e) {
                console.warn('Cleanup after termination failed:', e);
            }

            showExamAlert(message);
            setTimeout(() => {
                submitExam();
            }, 1500);
        }

        // Function to resume exam after pause
        function resumeExam() {
            const pauseModal = document.getElementById('pauseModal');
            const examContainer = document.getElementById('examContainer');

            // Hide the pause modal
            if (pauseModal) {
                pauseModal.style.display = 'none';
            }

            // Re-enable the exam container
            if (examContainer) {
                examContainer.style.pointerEvents = 'auto';
                examContainer.style.opacity = '1';
            }

            // Resume all detection
            isExamPaused = false;
            currentPausedType = null;
            
            // Resume sending frames to server
            if (running && !sendInterval && intervalMs > 0) {
                const sendIntervalMs = intervalMs * 3;
                sendInterval = setInterval(sendPreviewToServer, sendIntervalMs);
            }
            
            // Resume speech recognition if it was running
            if (speechStarted && recognition && recognition.state === 'inactive') {
                try {
                    recognition.start();
                } catch(e) {
                    console.debug('Speech recognition resume failed:', e);
                }
            }

            // Show resume messsage
            showExamAlert('Exam resumed. Please continue taking your exam.');
        }

        // Per-violation thresholds
        const VIOLATION_LIMITS = {
            phone: 1,
            twofaces: 3,
            loud_sound: 3,
            fullscreen_exit: 3,
            keyboard_shortcut: 3,
            right_click: 3,
            tab_switch: 3,
            face_absent: 3,
        };

        // Cooldown to avoid double-counting rapid duplicate events
        const TYPE_COOLDOWN_MS = 2000;
        // Per-type pause window after a violation (prevents continuous increments, e.g., face_absent)
        const PER_TYPE_PAUSE_MS = 10000;
        const lastPerTypeAlertTime = {};
        const perTypeBlockUntil = {};

        // Modify logAlert function to update immediately and trigger clip recording
        async function logAlert(type, message) {
            // Process any queued violations from immediate prevention script
            if (typeof window.processViolationQueue === 'function') {
                window.processViolationQueue();
            }
            
            // Stop counting once exam is completed/terminated to avoid extra violations
            if (examState.terminated || examState.completed) return;
            if (!alertsSession.sessionId) return;
            
            // Stop all detection when exam is paused
            if (isExamPaused) return;

            const now = Date.now();

            // If this type is currently in a pause window, ignore
            if (perTypeBlockUntil[type] && now < perTypeBlockUntil[type]) {
                return;
            }

            // Debounce per type to prevent double-counting rapid duplicate events
            if (lastPerTypeAlertTime[type] && (now - lastPerTypeAlertTime[type] < TYPE_COOLDOWN_MS)) {
                return; // ignore duplicate within cooldown
            }
            lastPerTypeAlertTime[type] = now;

            // Add timestamp to local flags array
            alertsSession.flags[type].push({
                timestamp: new Date().toISOString(),
                message: message
            });

            const perTypeCount = alertsSession.flags[type].length;

            // Update student Alert Distribution panel
            updateStudentAlertDistribution(type);

            // Start cheating clip recording if not already recorded
            if (!alertsSession.clipRecorded && (type === 'phone' || type === 'twofaces' || type === 'loud_sound' || type === 'face_absent')) {
                startCheatingClip();
            }

            // Per-type enforcement with thresholds
            const limit = VIOLATION_LIMITS[type];
            if (limit) {
                if (perTypeCount >= limit) {
                    terminateExam(`üö® THIRD VIOLATION (${type}): Exam terminated. Marked as incomplete (0 points).`);
        } else if (perTypeCount === 2) {
            // Second violation of this type: pause until continue clicked
            isExamPaused = true; // Pause all detection
            currentPausedType = type;
            
            // Stop sending frames to server while paused
            if (sendInterval) {
                clearInterval(sendInterval);
                sendInterval = null;
            }
            
            // Stop speech recognition while paused
            if (recognition && recognition.state !== 'inactive') {
                try {
                    recognition.stop();
                } catch(e) {
                    console.debug('Speech recognition stop failed:', e);
                }
            }
            
            showExamAlert(`üö® SECOND ${type.toUpperCase()} VIOLATION: Exam paused. Click Continue to resume.`);
            perTypeBlockUntil[type] = Date.now() + PER_TYPE_PAUSE_MS;
            const examContainer = document.getElementById('examContainer');
            if (examContainer) {
                examContainer.style.pointerEvents = 'none';
                examContainer.style.opacity = '0.5';
            }
            const pauseModal = document.getElementById('pauseModal');
            const pauseMessage = document.getElementById('pauseMessage');
            if (pauseMessage) {
                pauseMessage.textContent = `üö® SECOND ${type.toUpperCase()} VIOLATION: Click Continue to resume the exam.`;
            }
            if (pauseModal) {
                pauseModal.style.display = 'flex';
            }
        } else if (perTypeCount === 1) {
            // First violation: pause until continue clicked
            isExamPaused = true; // Pause all detection
            currentPausedType = type;
            
            // Stop sending frames to server while paused
            if (sendInterval) {
                clearInterval(sendInterval);
                sendInterval = null;
            }
            
            // Stop speech recognition while paused
            if (recognition && recognition.state !== 'inactive') {
                try {
                    recognition.stop();
                } catch(e) {
                    console.debug('Speech recognition stop failed:', e);
                }
            }
            
            showExamAlert(`‚ö†Ô∏è FIRST ${type.replace('_', ' ').toUpperCase()} VIOLATION: Exam paused. Click Continue to resume.`);
            perTypeBlockUntil[type] = Date.now() + PER_TYPE_PAUSE_MS;
            const examContainer = document.getElementById('examContainer');
            if (examContainer) {
                examContainer.style.pointerEvents = 'none';
                examContainer.style.opacity = '0.5';
            }
            const pauseModal = document.getElementById('pauseModal');
            const pauseMessage = document.getElementById('pauseMessage');
            if (pauseMessage) {
                pauseMessage.textContent = `‚ö†Ô∏è FIRST ${type.replace('_', ' ').toUpperCase()} VIOLATION: Click Continue to resume the exam.`;
            }
            if (pauseModal) {
                pauseModal.style.display = 'flex';
            }
        }
            }

            // Update database immediately
            try {
                await fetch(`/edit/${alertsSession.sessionId}?collection=proctoring_sessions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        flags: alertsSession.flags
                    })
                });
            } catch (err) {
                console.error('Error updating alerts:', err);
            }
        }

        // Permission handling
        let permissionsGranted = false;

        async function requestPermissions() {
            try {
                // Reduced frame size for Render free tier memory optimization (640x480 instead of 1280x720)
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: 640, height: 480 },
                    audio: true
                });

                // Stop the test stream
                stream.getTracks().forEach(track => track.stop());

                permissionsGranted = true;
                document.getElementById('permissionModal').style.display = 'none';
                document.getElementById('examContainer').style.display = 'flex';

                // Now start the exam
                await startExam();

            } catch (err) {
                alert('Camera and microphone access are required to take this exam. Please allow access and try again.');
                console.error('Permission denied:', err);
            }
        }

        function denyPermissions() {
            alert('Camera and microphone access are required to take this exam. Please refresh the page and allow access.');
        }

        // Start exam after permissions granted
        async function startExam() {
            try {
                await initExam();
                await initAlertsSession();
                await initModels();
                await initSecurityFeatures(); // Add security features
                // Try to enter fullscreen (best effort, requires user gesture)
                try {
                    const el = document.documentElement || document.body;
                    if (el.requestFullscreen) el.requestFullscreen().catch(()=>{});
                    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
                    else if (el.msRequestFullscreen) el.msRequestFullscreen();
                } catch (e) {
                    console.debug('Fullscreen request failed (ignored):', e);
                }
                // Start speech recognition after ensuring microphone access
                // Wait longer to ensure microphone permissions are fully processed and stream is ready
                setTimeout(async () => {
                    try {
                        if (micStatus) micStatus.innerText = 'Initializing speech recognition...';
                        
                        // Ensure we have microphone access before starting
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            audio: {
                                echoCancellation: true,
                                noiseSuppression: true,
                                autoGainControl: true
                            },
                            video: false 
                        });
                        audioStreamForSpeech = stream;
                        
                        // Start speech recognition after confirming mic access
                        await startSpeechRecognition();
                    } catch (e) {
                        console.warn('Speech recognition initialization failed:', e);
                        if (micStatus) micStatus.innerText = 'Speech recognition unavailable - retrying...';
                        // Retry after delay
                        setTimeout(() => {
                            startSpeechRecognition().catch(err => {
                                console.warn('Speech recognition retry failed:', err);
                            });
                        }, 3000);
                    }
                }, 1000); // Increased delay to ensure mic permissions are ready
            } catch(err) {
                labelDiv.innerText = 'Initialization error: '+ (err && err.message ? err.message : String(err));
                return;
            }
            // Keep existing detection initialization
            examState.active = true;
        }

        // Start exam when page loads
        window.addEventListener('load', () => {
            // Show permission modal first
            document.getElementById('permissionModal').style.display = 'flex';
        });
    </script>
    
    <!-- Keep existing detection script -->
    <script>
        // Elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const labelDiv = document.getElementById('label');
        const processedImg = document.getElementById('processed');
        const barFill = document.getElementById('barFill');
        const probText = document.getElementById('probText');

        // Captions elements
        const captionsEl = document.getElementById('captions');

       // Alert elements
        const alertNoFace = document.getElementById('alert-noface');
        const alertTwoFaces = document.getElementById('alert-multiplefaces');
        const alertPhone = document.getElementById('alert-phone');
        const alertLoudSound = document.getElementById('alert-loudsound');

        const alertMVoices = document.getElementById('alert-mvoices');

        // Mic UI
        const micFillEl = document.getElementById('micFill');
        const micStatus = document.getElementById('micStatus');

        function setAlert(el, on, text){
            if(!el) return;
            if(on){
                if(text) el.textContent = text;
                el.classList.add('show');
            } else {
                el.classList.remove('show');
            }
        }

        // Debug helpers
        window.addEventListener('error', (e) => {
            console.error('Window error', e);
            try { labelDiv.innerText = 'Error: ' + (e.message || e.error || e); } catch {}
        });
        window.addEventListener('unhandledrejection', (ev) => {
            console.error('Unhandled rejection', ev);
            try { labelDiv.innerText = 'Promise error: ' + (ev.reason && ev.reason.message ? ev.reason.message : String(ev.reason)); } catch {}
        });

        labelDiv.innerText = 'Initializing and auto-starting...';

        let useFront = true;
        let running = false;
        let sendInterval = null;
        // Server-side processing interval (ms)
        // For Render free tier: Use 10000-15000ms (10-15 seconds) to avoid overload
        // For paid hosting: Can use 500-1000ms (0.5-1 second) for real-time detection
        // Set to 0 to disable server-side processing entirely (use client-side only)
        let intervalMs = 15000; // Default: 15 seconds (PC and mobile use same lightweightness - both use 3x multiplier = 45 seconds)

        // Performance optimizations (same for mobile and PC)
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let frameCount = 0;
        let lastProcessedTime = 0;
        const targetFPS = 10; // Consistent 10 FPS for all devices
        const frameInterval = 1000 / targetFPS;

        // Models
        let cocoModel = null;
        let faceMesh = null;
        let camera = null;

        const detCanvas = document.createElement('canvas');
        const detCtx = detCanvas.getContext('2d');
        const DET_W = 640;
        const DET_H = 360;
        detCanvas.width = DET_W;
        detCanvas.height = DET_H;

        async function initModels(){
            labelDiv.innerText = 'Loading models...';
            try {
                cocoModel = await cocoSsd.load();
            } catch (e) {
                console.warn('coco load failed', e);
                cocoModel = null;
            }
            try {
                faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                });
                faceMesh.setOptions({
                    maxNumFaces: 4,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                faceMesh.onResults(onFaceResults);
            } catch (e) {
                console.error('faceMesh init failed', e);
                throw e;
            }
            labelDiv.innerText = 'Models loaded';
        }

        function stopTracks(stream){
            try{
                if(!stream) return;
                stream.getTracks().forEach(t => { try{ t.stop(); }catch(e){} });
            }catch(e){}
        }

        async function startCameraStream() {
            try {
                // Add timeout promise
                // Note: Only request video here - audio will be reused from initial stream
                // This prevents multiple getUserMedia calls which can fail on Render
                const streamPromise = navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: useFront ? 'user' : 'environment',
                        width: 640,
                        height: 360
                    },
                    audio: false  // Explicitly don't request audio here - reuse from main stream
                });
                
                const stream = await Promise.race([
                    streamPromise,
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Camera permission timeout')), 10000))
                ]);

                if(video.srcObject) {
                    stopTracks(video.srcObject);
                }
                video.srcObject = stream;
                await video.play();
                
                // Initialize camera after successful stream
                camera = new Camera(video, {
                    onFrame: async () => {
                        const now = performance.now();
                        if (now - lastProcessedTime >= frameInterval) {
                            lastProcessedTime = now;
                            frameCount++;
                            if(faceMesh) await faceMesh.send({image: video});
                        }
                    },
                    width: 640,
                    height: 360
                });
                camera.start();

            } catch(err) {
                labelDiv.innerText = 'Camera error: ' + (err.message || err);
                console.error('Camera start failed:', err);
                // Add retry button
                const retryBtn = document.createElement('button');
                retryBtn.innerText = 'Retry Camera';
                retryBtn.onclick = startCameraStream;
                labelDiv.appendChild(retryBtn);
            }
        }

        // gaze estimator (unchanged)
        function estimateGazeFromLandmarks(landmarks){
            if(!landmarks || landmarks.length === 0) return {looking:false, yaw:0, pitch:0};
            const leftOuter = landmarks[33];
            const rightOuter = landmarks[263];
            const eyeCenter = { x: (leftOuter.x + rightOuter.x) / 2, y: (leftOuter.y + rightOuter.y) / 2 };
            const faceWidth = Math.abs(rightOuter.x - leftOuter.x) + 1e-6;
            let leftIrisCenter = null, rightIrisCenter = null;
            if(landmarks.length > 468){
                const li = [468,469,470,471].map(i=>landmarks[i]);
                const ri = [473,474,475,476].map(i=>landmarks[i]);
                leftIrisCenter = li.reduce((acc,p)=>({x:acc.x+p.x,y:acc.y+p.y}), {x:0,y:0});
                rightIrisCenter = ri.reduce((acc,p)=>({x:acc.x+p.x,y:acc.y+p.y}), {x:0,y:0});
                leftIrisCenter.x /= li.length; leftIrisCenter.y /= li.length;
                rightIrisCenter.x /= ri.length; rightIrisCenter.y /= ri.length;
            }
            let yaw = 0, pitch = 0;
            if(leftIrisCenter && rightIrisCenter){
                const irisCenter = { x: (leftIrisCenter.x + rightIrisCenter.x)/2, y: (leftIrisCenter.y + rightIrisCenter.y)/2 };
                yaw = (irisCenter.x - eyeCenter.x) / faceWidth;
                pitch = (irisCenter.y - eyeCenter.y) / faceWidth;
            }else{
                const nose = landmarks[1];
                yaw = (nose.x - eyeCenter.x) / faceWidth;
                pitch = (nose.y - eyeCenter.y) / faceWidth;
            }
            const absYaw = Math.abs(yaw);
            const absPitch = Math.abs(pitch);
            const yawThresh = 0.18;
            const pitchUpThresh = 0.20;
            const pitchDownThresh = 0.24;
            const looking = (absYaw < yawThresh) && (pitch > -pitchUpThresh) && (pitch < pitchDownThresh);
            
            return { looking, yaw, pitch };
        }

        async function onFaceResults(results){
            // Stop all detection processing when exam is paused
            if (isExamPaused) return;
            
            const faces = results.multiFaceLandmarks || [];

            // Skip processing if no faces and we're on mobile (reduce CPU usage)
            if (isMobile && faces.length === 0 && frameCount % 3 !== 0) {
                return;
            }

            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            let lookingCount = 0;
            faces.forEach((landmarks, idx) => {
                drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, {color: '#6ee7b7', lineWidth: 0.5});
                drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, {color: '#6ee7b7'});
                drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, {color: '#6ee7b7'});

                const gaze = estimateGazeFromLandmarks(landmarks);
                if(gaze.looking) lookingCount++;

                const x = landmarks[1].x * canvas.width;
                const y = (landmarks[10].y * canvas.height) - 8;
                ctx.fillStyle = gaze.looking ? 'rgba(0,200,80,0.95)' : 'rgba(255,80,80,0.95)';
                ctx.font = '16px Inter, sans-serif';
                ctx.fillText(`${gaze.looking ? 'LOOKING' : 'NOT'}`, x, y);
            });

            let phoneDetections = [];
            // Reduce object detection frequency on ALL devices to improve performance
            if(cocoModel && frameCount % 5 === 0){
                try{
                    detCtx.clearRect(0,0,DET_W,DET_H);
                    detCtx.drawImage(video, 0, 0, DET_W, DET_H);
                    const detections = await cocoModel.detect(detCanvas, 5); // Consistent low threshold for all devices
                    phoneDetections = detections.filter(d => {
                        const cls = String(d.class).toLowerCase();
                        return cls.includes('cell') && cls.includes('phone') || cls === 'cell phone' || cls === 'mobile phone' || cls === 'phone';
                    });
                    phoneDetections.forEach(d => {
                        let [x,y,w,h] = d.bbox;
                        const scaleX = canvas.width / DET_W;
                        const scaleY = canvas.height / DET_H;
                        const rx = x * scaleX, ry = y * scaleY, rw = w * scaleX, rh = h * scaleY;
                        ctx.strokeStyle = '#ff8c42';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(rx, ry, rw, rh);
                        ctx.fillStyle = '#ff8c42';
                        ctx.font = '16px Inter, sans-serif';
                        ctx.fillText(`${d.class} ${(d.score*100).toFixed(0)}%`, rx + 6, ry + 18);
                    });
                }catch(e){
                    console.debug('coco error', e);
                }
            }

            // Alerts logic
            // 0) No face - with mobile grace period handling
            if (faces.length === 0) {
                // On mobile, skip face_absent alerts during grace period after returning from app switch
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const skipFaceAlert = isMobile && mobileExitGracePeriod;

                if (!skipFaceAlert) {
                    setAlert(alertNoFace, true, 'No face detected!');
                    logAlert('face_absent', 'No face detected!');
                } else {
                    // During mobile grace period, just show a subtle indicator without alerting
                    setAlert(alertNoFace, true, 'Camera stabilizing...');
                    console.log('Face detection skipped during mobile grace period');
                }
            } else {
                setAlert(alertNoFace, false);
            }

            // 1) Multiple faces
            if (faces.length >= 2) {
                setAlert(alertTwoFaces, true, `Multiple faces detected (${faces.length})`);
                logAlert('twofaces', `Multiple faces detected (${faces.length})`);
            } else {
                setAlert(alertTwoFaces, false);
            }



            // 3) Phone detected - IMMEDIATE EXAM TERMINATION
            if (phoneDetections.length > 0) {
                setAlert(alertPhone, true, `Phone detected (${phoneDetections.length})`);
                logAlert('phone', `Phone detected (${phoneDetections.length})`);
                if (!examTerminated) {
                    examTerminated = true;
                    examState.terminated = true;
                    examState.forceZeroScore = true;
                    // Capture elapsed time immediately before termination
                    if (examStartTime !== null) {
                        const elapsedMs = Date.now() - examStartTime;
                        examState.finalElapsedTime = Math.floor(elapsedMs / 1000);
                    } else {
                        examState.finalElapsedTime = examElapsedTime;
                    }
                    totalAlertCount = 1; // Set alert count to 1 for immediate termination
                    showExamAlert('üö® PHONE DETECTED: Exam terminated immediately. Your exam will be marked as incomplete.');
                    setTimeout(() => {
                        submitExam();
                    }, 2000);
                }
            } else {
                setAlert(alertPhone, false);
            }

            labelDiv.innerText = `Faces: ${faces.length} ‚Ä¢ Looking: ${lookingCount} ‚Ä¢ Phones: ${phoneDetections.length}`;
            const p = faces.length ? (lookingCount / faces.length) : 0;
            barFill.style.width = `${Math.round(p*100)}%`;
            probText.innerText = `${Math.round(p*100)}%`;

            // Reduce image quality on mobile for better performance
            const imageQuality = isMobile ? 0.6 : 0.8;
            processedImg.src = canvas.toDataURL('image/jpeg', imageQuality);
        }

        async function sendPreviewToServer(){
            if(!processedImg.src) return;
            
            // Skip if server-side processing is disabled (intervalMs = 0)
            if (intervalMs === 0) return;
            
            // Stop sending frames when exam is paused
            if (isExamPaused) return;

            // Reduce server upload frequency on ALL devices
            if (frameCount % 3 !== 0) return;

            try{
                const res = await fetch(processedImg.src);
                const blob = await res.blob();
                const form = new FormData();
                form.append('frame', blob, 'client.jpg');
                if (alertsSession.userId) {
                    form.append('user_id', alertsSession.userId);
                }
                const sessionId = alertsSession.sessionId ? `?session_id=${encodeURIComponent(alertsSession.sessionId)}` : '';
                
                // Add timeout for Render free tier (30 second limit)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 25000); // 25 second timeout
                
                try {
                    await fetch(`/predict${sessionId}`, {
                        method:'POST', 
                        body: form,
                        signal: controller.signal
                    });
                } finally {
                    clearTimeout(timeoutId);
                }
            }catch(e){
                // Silently fail to avoid disrupting exam flow
                // Server-side processing is optional (client-side detection still works)
                console.debug('Server-side processing skipped:', e.message);
            }
        }

        // ================= SPEECH RECOGNITION =================
        let recognition = null;
        let captionsClearTimeout = null;
        let speechNeedsUserRestart = false;
        let speechStarted = false;
        let audioStreamForSpeech = null; // Store audio stream for speech recognition
        let speechRetryCount = 0;
        const MAX_SPEECH_RETRIES = 5;

        async function startSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.warn('Speech recognition not supported in this browser');
                if (micStatus) {
                    micStatus.innerText = 'Speech recognition not supported';
                }
                // Don't show alert - allow app to continue without speech recognition
                return;
            }

            // Check if already running - use state property if available
            if (recognition) {
                const state = recognition.state || (recognition.continuous ? 'listening' : 'inactive');
                if (state === 'listening' || state === 'starting') {
                    console.log('Speech recognition already running');
                    return;
                }
            }

            // Ensure microphone access is available before starting speech recognition
            // This is critical for Render hosting and prevents audio-capture errors
            try {
                // Check if we have an active audio stream
                if (!audioStreamForSpeech || audioStreamForSpeech.getAudioTracks().length === 0 || 
                    audioStreamForSpeech.getAudioTracks().every(track => track.readyState === 'ended')) {
                    
                    if (micStatus) {
                        micStatus.innerText = 'Requesting microphone access...';
                    }
                    
                    // Request microphone access explicitly for speech recognition
                    // Use a short timeout to avoid blocking
                    const micPromise = navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        },
                        video: false 
                    });
                    
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Microphone access timeout')), 5000)
                    );
                    
                    audioStreamForSpeech = await Promise.race([micPromise, timeoutPromise]);
                    
                    console.log('Microphone access granted for speech recognition');
                    
                    // Keep the stream alive for speech recognition
                    audioStreamForSpeech.getAudioTracks().forEach(track => {
                        track.addEventListener('ended', () => {
                            console.warn('Audio track ended, will retry speech recognition');
                            audioStreamForSpeech = null;
                            if (speechRetryCount < MAX_SPEECH_RETRIES) {
                                speechRetryCount++;
                                setTimeout(() => startSpeechRecognition(), 2000);
                            }
                        });
                    });
                }
            } catch (micErr) {
                console.warn('Microphone access check failed for speech recognition:', micErr);
                speechRetryCount++;
                
                if (speechRetryCount >= MAX_SPEECH_RETRIES) {
                    if (micStatus) {
                        micStatus.innerText = 'Microphone access unavailable';
                    }
                    console.error('Max retries reached for microphone access');
                    return;
                }
                
                // Retry with exponential backoff
                const retryDelay = Math.min(1000 * Math.pow(2, speechRetryCount), 10000);
                if (micStatus) {
                    micStatus.innerText = `Retrying microphone access (${speechRetryCount}/${MAX_SPEECH_RETRIES})...`;
                }
                setTimeout(() => startSpeechRecognition(), retryDelay);
                return;
            }

            // Reset retry count on successful mic access
            speechRetryCount = 0;

            try {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                // Create new instance each time to avoid state issues
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US'; // Can be made configurable
                recognition.maxAlternatives = 1; // Reduce processing overhead
                // Enable better speech detection
                recognition.serviceURI = ''; // Use default service

                recognition.onstart = () => {
                    speechStarted = true;
                    speechRetryCount = 0; // Reset retry count on successful start
                    console.log('Speech recognition started successfully');
                    // Show captions area with "Listening..." message
                    const captionsElement = document.getElementById('captions');
                    if (captionsElement) {
                        captionsElement.style.display = 'block';
                        captionsElement.textContent = 'Listening...';
                        captionsElement.style.background = 'rgba(0,0,0,0.5)';
                        captionsElement.style.border = 'none';
                        captionsElement.style.color = '#e6eef8';
                        captionsElement.style.fontWeight = 'normal';
                        console.log('Captions element found and displayed');
                        
                        // Clear "Listening..." after 5 seconds if no speech detected (longer timeout)
                        if (captionsClearTimeout) {
                            clearTimeout(captionsClearTimeout);
                        }
                        captionsClearTimeout = setTimeout(() => {
                            if (captionsElement && captionsElement.textContent === 'Listening...') {
                                // Keep showing "Listening..." but make it less prominent
                                captionsElement.style.opacity = '0.6';
                            }
                        }, 5000);
                    } else {
                        console.error('Captions element not found!');
                    }
                    if (micStatus) {
                        micStatus.innerText = 'Listening for speech...';
                    }
                };

                recognition.onresult = (event) => {
                    let finalTranscript = '';
                    let interimTranscript = '';

                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        const confidence = event.results[i][0].confidence || 0.5;
                        
                        // Only process transcripts with reasonable confidence (>= 0.3)
                        if (confidence >= 0.3) {
                            if (event.results[i].isFinal) {
                                finalTranscript += transcript + ' ';
                            } else {
                                interimTranscript += transcript + ' ';
                            }
                        }
                    }

                    // Get captions element fresh each time to ensure it exists
                    const captionsElement = document.getElementById('captions');
                    
                    // Clear any existing timeout
                    if (captionsClearTimeout) {
                        clearTimeout(captionsClearTimeout);
                        captionsClearTimeout = null;
                    }
                    
                    // Display captions - show both final and interim results
                    let displayText = '';
                    if (finalTranscript.trim()) {
                        displayText = finalTranscript.trim();
                    }
                    if (interimTranscript.trim()) {
                        displayText = (displayText ? displayText + ' ' : '') + interimTranscript.trim() + '...';
                    }

                    // Update captions if there's any text (interim or final)
                    if (captionsElement) {
                        if (displayText) {
                            captionsElement.style.display = 'block';
                            captionsElement.textContent = displayText;
                            console.log('Speech detected:', displayText);
                            
                            // Set timeout to clear captions after 5 seconds of no new speech
                            captionsClearTimeout = setTimeout(() => {
                                if (captionsElement) {
                                    captionsElement.textContent = '';
                                    captionsElement.style.display = 'none';
                                }
                            }, 5000);
                        } else {
                            // Keep showing "Listening..." if no speech yet
                            captionsElement.style.display = 'block';
                            captionsElement.textContent = 'Listening...';
                        }
                    } else {
                        console.error('Captions element not found in onresult!');
                    }

                    // Check for exam content on both interim and final transcripts
                    // This is critical for detecting when students read answers/choices
                    const fullTranscript = (finalTranscript + ' ' + interimTranscript).trim();
                    if (fullTranscript && fullTranscript.length >= 3) {
                        // Check if speech contains exam questions or answers
                        // This will detect if student is reading exam content aloud
                        checkForExamContent(fullTranscript);
                    }

                    // Log final transcripts to alerts session (even if not exam content)
                    // This helps track all speech during the exam
                    if (finalTranscript.trim()) {
                        if (alertsSession && alertsSession.flags) {
                            // Initialize captions array if it doesn't exist
                            if (!alertsSession.flags.captions) {
                                alertsSession.flags.captions = [];
                            }
                            alertsSession.flags.captions.push({
                                timestamp: new Date().toISOString(),
                                text: finalTranscript.trim()
                            });
                        }
                        // Update student alert distribution
                        updateStudentAlertDistribution('captions');
                    }
                };

                recognition.onerror = (event) => {
                    // Always re-fetch the captions element to avoid undefined references
                    const captionsEl = document.getElementById('captions');
                    console.warn('Speech recognition error:', event.error);

                    // Handle specific error types
                    switch(event.error) {
                        case 'aborted':
                            // Silently retry - aborted is usually normal (user interaction, etc.)
                            setTimeout(() => startSpeechRecognition(), 3000);
                            break;
                        case 'network':
                            // Network error - show warning but don't spam
                            if (micStatus) {
                                micStatus.innerText = 'Network error. Retrying...';
                            }
                            setTimeout(() => startSpeechRecognition(), 5000);
                            break;
                        case 'not-allowed':
                            // Permission denied - show alert once
                            if (micStatus) {
                                micStatus.innerText = 'Microphone permission denied';
                            }
                            console.error('Microphone permission denied for speech recognition');
                            // Don't retry if permission denied
                            break;
                        case 'no-speech':
                            // No speech detected is NORMAL - don't show error message
                            // Just silently restart - this happens when user is quiet
                            setTimeout(() => startSpeechRecognition(), 3000);
                            // Keep captions showing "Listening..." when no speech
                            if (captionsEl) {
                                captionsEl.style.display = 'block';
                                captionsEl.textContent = 'Listening...';
                            }
                            break;
                        case 'audio-capture':
                            // Audio capture failed - common on Render/HTTPS issues
                            // Reset audio stream and retry
                            console.warn('Speech recognition audio-capture failed, resetting audio stream...');
                            if (audioStreamForSpeech) {
                                audioStreamForSpeech.getAudioTracks().forEach(track => track.stop());
                                audioStreamForSpeech = null;
                            }
                            
                            speechRetryCount++;
                            if (speechRetryCount >= MAX_SPEECH_RETRIES) {
                                if (micStatus) {
                                    micStatus.innerText = 'Audio capture unavailable';
                                }
                                console.error('Max retries reached for audio-capture');
                                break;
                            }
                            
                            if (micStatus) {
                                micStatus.innerText = `Audio unavailable, retrying (${speechRetryCount}/${MAX_SPEECH_RETRIES})...`;
                            }
                            // Retry with exponential backoff
                            const retryDelay = Math.min(2000 * Math.pow(2, speechRetryCount), 10000);
                            setTimeout(() => {
                                try {
                                    startSpeechRecognition();
                                } catch (e) {
                                    console.warn('Speech recognition retry failed:', e);
                                    if (micStatus) {
                                        micStatus.innerText = 'Speech recognition unavailable';
                                    }
                                }
                            }, retryDelay);
                            break;
                        default:
                            // Other errors - silently retry
                            console.warn('Speech recognition error:', event.error, '- retrying...');
                            setTimeout(() => startSpeechRecognition(), 3000);
                    }

                    // Only update captions for errors that should be shown to user
                    if (event.error !== 'no-speech' && event.error !== 'aborted') {
                        if (captionsEl && (event.error === 'network' || event.error === 'audio-capture')) {
                            captionsEl.textContent = 'Error: ' + event.error;
                        }
                    }
                };

                recognition.onend = () => {
                    console.log('Speech recognition ended');
                    if (document.visibilityState === 'visible' && !speechNeedsUserRestart) {
                        // Auto-restart only when page is visible and we don't require a user tap
                        // Add increased delay for better stability on Render
                        setTimeout(() => {
                            try {
                                startSpeechRecognition();
                            } catch (e) {
                                console.warn('Speech recognition restart failed:', e);
                                if (micStatus) {
                                    micStatus.innerText = 'Speech recognition unavailable';
                                }
                                // Don't keep retrying if it consistently fails
                            }
                        }, 3000); // Increased delay for better stability
                    } else {
                        if (micStatus) micStatus.innerText = 'Speech paused (tap to resume)';
                    }
                };

                recognition.start();
                console.log('Speech recognition start() called');
            } catch (e) {
                console.warn('Failed to start speech recognition:', e);
                const captionsElement = document.getElementById('captions');
                if (captionsElement) {
                    captionsElement.textContent = 'Speech recognition unavailable';
                    captionsElement.style.display = 'block';
                    // Auto-hide after 5 seconds
                    setTimeout(() => {
                        if (captionsElement) {
                            captionsElement.style.display = 'none';
                        }
                    }, 5000);
                }
                if (micStatus) {
                    micStatus.innerText = 'Speech recognition unavailable';
                }
                // Don't show alert - allow app to continue without speech recognition
                // Retry after delay
                setTimeout(() => {
                    try {
                        startSpeechRecognition();
                    } catch (retryErr) {
                        console.warn('Speech recognition retry failed:', retryErr);
                    }
                }, 10000); // Retry after 10 seconds
            }
        }

        function stopSpeechRecognition() {
            try {
                if (recognition) {
                    recognition.onend = null; // prevent auto-restart during manual stop
                    recognition.stop();
                }
            } catch (e) {
                console.warn('Failed to stop speech recognition:', e);
            }
        }

        // Pause speech recognition when the tab is hidden; require user tap to resume
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                speechNeedsUserRestart = true;
                stopSpeechRecognition();
                if (micStatus) micStatus.innerText = 'Speech paused (app hidden)';
            } else {
                // Wait for explicit user gesture to resume (see click handler below)
                if (micStatus) micStatus.innerText = 'Tap mic to resume speech';
            }
        });

        // Simple user gesture handler to resume speech recognition
        document.addEventListener('click', () => {
            if (!speechNeedsUserRestart) return;
            speechNeedsUserRestart = false;
            try {
                startSpeechRecognition();
            } catch (e) {
                console.warn('Speech resume failed:', e);
                speechNeedsUserRestart = true;
            }
        }, { passive: true });

        // ================= AUDIO (MIC) DETECTION =================
        // Balanced thresholds by default (suitable for classroom)
        let audioCtx = null;
        let analyser = null;
        let micStream = null;
        let micDataArray = null;
        let prevSpec = null;

        async function startMicAnalysis(){
            // request mic access
            try{
                // Reuse audio stream if available (from main getUserMedia call)
                if (!micStream && audioStreamForSpeech) {
                    micStream = audioStreamForSpeech;
                } else if (!micStream) {
                    micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    // Store for speech recognition if not already stored
                    if (!audioStreamForSpeech) {
                        audioStreamForSpeech = micStream;
                    }
                }
            }catch(e){
                micStatus.innerText = 'Microphone blocked';
                console.warn('mic access denied', e);
                return;
            }

            try{
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const src = audioCtx.createMediaStreamSource(micStream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048; // better resolution for voice
                analyser.smoothingTimeConstant = 0.3;
                src.connect(analyser);

                const bufferLength = analyser.frequencyBinCount;
                micDataArray = new Uint8Array(bufferLength);
                prevSpec = new Float32Array(bufferLength);
                micStatus.innerText = 'Listening';
                // analyze loop
                const specFloat = new Float32Array(bufferLength);

                function analyzeAudio(){
                    if(!analyser) return;
                    
                    // Stop audio detection when exam is paused
                    if (isExamPaused) {
                        requestAnimationFrame(analyzeAudio);
                        return;
                    }
                    
                    analyser.getByteFrequencyData(micDataArray);

                    // compute RMS-like loudness from freq bins
                    let sum = 0;
                    for(let i=0;i<bufferLength;i++){
                        const v = micDataArray[i] / 255;
                        sum += v*v;
                    }
                    const rms = Math.sqrt(sum / bufferLength); // 0..1-ish

                    // update mic meter
                    const meterPct = Math.min(1, rms*1.6); // scale so normal talk ~0.35-0.6
                    micFillEl.style.width = `${Math.round(meterPct*100)}%`;
                    micStatus.innerText = `${Math.round(meterPct*100)}%`;

                    // Loud detection thresholds - CONFIGURED FOR LOUD SOUND DETECTION
                    // Adjust this value to change sensitivity:
                    // - 0.60 (60%) = very sensitive, detects background noise
                    // - 0.75 (75%) = moderate, detects normal talking (CURRENT SETTING)
                    // - 0.90 (90%) = less sensitive, mainly loud sounds
                    // - 0.95+ (95%+) = only very loud sounds
                    const LOUD_THRESHOLD = 0.75; // Set to 0.75 to detect normal talking and louder sounds
                    const loudDetected = meterPct > LOUD_THRESHOLD;
                    if (loudDetected) {
                        setAlert(alertLoudSound, true, `Loud sound detected (${Math.round(meterPct*100)}%)`);
                        logAlert('loud_sound', `Loud sound detected (${Math.round(meterPct*100)}%)`);
                    } else {
                        setAlert(alertLoudSound, false);
                    }



                    requestAnimationFrame(analyzeAudio);
                }
                analyzeAudio();
            }catch(e){
                micStatus.innerText = 'Mic error';
                console.error('startMicAnalysis error', e);
            }
        }



        // Auto-start on load: initialize models and immediately start camera + processing + mic
        window.addEventListener('load', async () => {
            try{
                await initModels();
            }catch(err){
                labelDiv.innerText = 'Model load error: '+ (err && err.message ? err.message : String(err));
                return;
            }

            // try to get permission & preview then start full camera processing
            try{
                // Reduced frame size for Render free tier memory optimization (640x480)
                const constraints = { video: { facingMode: useFront ? 'user' : 'environment', width: 640, height: 480 }, audio: true };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                if(video.srcObject) stopTracks(video.srcObject);
                video.srcObject = stream;
                try{ await video.play(); }catch(e){ console.debug('preview play ignored', e); }

                // start MediaPipe faceMesh + camera stream (this will drive onFaceResults)
                await startCameraStream();

                // start recording the full session (use same stream if available)
                try { startMediaRecorder(stream); } catch(e) { console.warn('startMediaRecorder failed', e); }

                // mic analysis (no sound playback) - always start on all devices
                // Audio detection is essential for proctoring, so we always enable it
                startMicAnalysis().catch(e=>console.warn('mic start failed', e));

                // Do not auto-start speech recognition here; it is started from startExam via user gesture

                // mark running and start periodic send (if desired) - consistent frequency for all devices
                running = true;
                if(sendInterval) clearInterval(sendInterval);
                const sendIntervalMs = intervalMs * 3; // Consistent 45-second interval for all devices
                sendInterval = setInterval(sendPreviewToServer, sendIntervalMs);

            }catch(e){
                labelDiv.innerText = 'Camera preview error: '+ (e.message || e);
                console.error('preview getUserMedia failed', e);
            }
        });

        // expose interval setter
        window.setCaptureInterval = function(ms){
            intervalMs = ms;
            if(sendInterval){
                clearInterval(sendInterval);
                // Consistent 3x multiplier for all devices (PC and mobile same lightweightness)
                const sendIntervalMs = intervalMs * 3;
                sendInterval = setInterval(sendPreviewToServer, sendIntervalMs);
            }
        };

        // ----------------- MediaRecorder: record full session and upload -----------------
        window.mediaRecorder = null;
        window.mediaChunks = [];
        // alertsSession.videoUploadPromise will be set when upload starts; resolved when server confirms
        async function startMediaRecorder(stream) {
            if (!stream) return;
            try {
                const mime = (MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' :
                              (MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' : 'video/webm'));
                window.mediaChunks = [];
                window.mediaRecorder = new MediaRecorder(stream, { mimeType: mime, bitsPerSecond: 2000000 });
                window.mediaRecorder.ondataavailable = (ev) => {
                    if (ev.data && ev.data.size > 0) window.mediaChunks.push(ev.data);
                };
                window.mediaRecorder.onstop = async () => {
                    // assemble blob and upload to server
                    const blob = new Blob(window.mediaChunks, { type: mime });
                    window.mediaChunks = [];
                    if (!alertsSession.sessionId) {
                        console.warn('no session id to attach video to');
                        return;
                    }
                    const fd = new FormData();
                    fd.append('video', blob, `session_${alertsSession.sessionId}_${Date.now()}.webm`);
                    // store promise on alertsSession so submitExam can await
                    alertsSession.videoUploadPromise = fetch(`/upload_video?session_id=${encodeURIComponent(alertsSession.sessionId)}`, {
                        method: 'POST',
                        body: fd
                    }).then(async (res) => {
                        if(!res.ok) throw new Error('upload failed');
                        return res.json();
                    }).then((j) => {
                        console.log('video uploaded', j);
                        return j;
                    }).catch(e => { console.error('video upload error', e); throw e; }).finally(() => {
                        // clear reference after finishing
                        alertsSession.videoUploadPromise = null;
                    });
                    return alertsSession.videoUploadPromise;
                };
                window.mediaRecorder.start();
                console.log('MediaRecorder started', mime);
            } catch (e) {
                console.warn('Failed to start MediaRecorder', e);
            }
        }
        

    </script>
</body>
</html>
</html>